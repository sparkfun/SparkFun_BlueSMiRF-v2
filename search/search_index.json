{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Placeholder file for index redirect functionality.</p>"},{"location":"Arduino_Serial_LCD_BlueSMiRFs/","title":"Example 3 - Wireless Serial LCD","text":"<p>In this example, we will be using the basic serial UART example from the SerLCD tutorial. However, the wires between the SparkFun RedBoard will be replaced with a pair of BlueSMiRF v2s.</p> AVR-Based Serial Enabled LCDs Hookup Guide | Serial UART: Example Code - Basic"},{"location":"Arduino_Serial_LCD_BlueSMiRFs/#changing-the-baud-rate","title":"Changing the Baud Rate","text":"<p>Before using the BlueSMiRFs with the SerLCD, we need to make sure that the baud rates match. You can either change the baud rate on both BlueSMiRFs or the baud rate of the SerLCD. To keep the original Arduino code the same, let's change the baud rate on both of the BlueSMiRFs. This will also be a good exercise to change the baud rate using the AT Commands.</p> <p>Connect a USB-to-Serial converter to the BlueSMiRF. Depending on the BlueSMiRF that you have, you may need to solder headers. Then connect the USB cable between the converter and your computer.</p> USB-to-Serial Converter (CH340) to BlueSMiRF v2 Header with an Additional Stackable Header <p>Open a serial terminal and connect to the COM port at 115200 baud. Type $$$ within 60 seconds of powering the BlueSMiRF to enter command mode.</p> BlueSMiRF v2 Connected to Serial Terminal and in Command Mode <p>Type AT-SerialSpeed=9600 to change the baud rate to match the SerLCD's baud rate (which is set to 9600 baud by default). Enter ATW to save the settings.</p> Configuring the Baud Rate of the BlueSMiRF v2 <p>Now that the first BlueSMiRF v2 is configured, repeat the same steps explained above to change the baud rate of the second BlueSMiRF v2.</p>"},{"location":"Arduino_Serial_LCD_BlueSMiRFs/#hardware-hookup","title":"Hardware Hookup","text":"<p>Replacing the connection with the BlueSMiRFs is similar to the basic serial UART connection listed earlier in this tutorial. We'll be using it as a guide to wire everything up. Since the SerLCD is only receiving data to display, we only need to use its RX pin.</p> <p>From the microcontroller, you will need to wire the following pins. Since the BlueSMiRF v2 includes logic level circuitry on the TX and RX pins, we can wire the SparkFun RedBoard Plus directly to the pin when the switch for the microcontroller's logic level is set to 5V. Notice that we are only wiring software serial TX pin since we are just sending characters from the microcontroller to the SerLCD. Users that want to also connect software serial RX pin can also wire the connection to the BlueSMiRF v2's TXO but it is not necessary. We will assume that we are using power supplied from a USB port or USB power supply.</p> SparkFun RedBoard Plus(ATmega328P) Pinout              Transmitting BlueSMiRF v2Pinout              7 RXI 5V VCC GND GND <p>On the SerLCD side, we can simply insert the BlueSMiRF v2 in the SerLCD's USB-to-serial 1x6 header. For users that are using the BlueSMiRF v2 with headers and soldered male header pins on the SerLCD, you can place them in a breadboard. A 9V power supply and barrel jack adapter was used to power both boards. The + pin from the adapter was connected to the SerLCD's RAW pin which is regulated down to 3.3V. Of course, the - pin from the adapter was also connected for reference ground.</p> Receiving BlueSMiRF v2Pinout              SparkFun 16x2 SerLCDRGB Backlight (Qwiic) Pinout              Power Supply (5V TO 9V)with Barrel Jack Adapter              TXO RX VCC + RAW +, Center Positive Pin GND GND -, Sleeve <p>If you have not already, make sure to upload the Arduino example code from the basic serial UART example. For your convenience, the code shown below was pulled from the OpenLCD's Serial Examples folder. Select the board (in this case, the Tools &gt; Board &gt; Arduino AVR Boards (arduino) &gt; Arduino Uno) and COM port that the board enumerated to. Then hit the upload button.</p> <pre><code>/*\n OpenLCD is an LCD with serial/I2C/SPI interfaces.\n By: Nathan Seidle\n SparkFun Electronics\n Date: April 19th, 2015\n License: This code is public domain but you buy me a beer if you use this and we meet someday (Beerware license).\n\n This example shows how to display a counter on the display over serial. We use software serial because if \n OpenLCD is attached to an Arduino's hardware serial port during bootloading  it can cause problems for both devices.\n\n To get this code to work, attached an OpenLCD to an Arduino Uno using the following pins:\n RX (OpenLCD) to Pin 7 (Arduino)\n VIN to 5V\n GND to GND\n\n*/\n\n#include &lt;SoftwareSerial.h&gt;\n\nSoftwareSerial OpenLCD(6, 7); //RX, TX\n\nbyte counter = 0;\n\nvoid setup()\n{\n  Serial.begin(9600); //Start serial communication at 9600 for debug statements\n  Serial.println(\"OpenLCD Example Code\");\n\n  OpenLCD.begin(9600); //Start communication with OpenLCD\n}\n\nvoid loop()\n{\n  //Send the clear command to the display - this returns the cursor to the beginning of the display\n  OpenLCD.write('|'); //Setting character\n  OpenLCD.write('-'); //Clear display\n\n  OpenLCD.print(\"Hello World!    Counter: \"); //For 16x2 LCD\n  //OpenLCD.print(\"Hello World!        Counter: \"); //For 20x4 LCD\n  OpenLCD.print(counter++);\n\n  delay(250); //Hang out for a bit\n}\n</code></pre> <p>With both boards powered, follow the steps to pair and connect the two BlueSMiRFs together. If all is well, you should see the RedBoard Plus transmitting the same message to the SerLCD. Instead of a wired connection, a pair of BlueSMiRF's were used!</p> Wireless Serial LCD with the RedBoard Plus <p>Try adding a Qwiic-enabled device like the Human Presence and Motion Sensor - (STHS34PF80) to the RedBoard Plus and writing code to display a message notifying you when someone has passed by a door. Then place the SerLCD by your desk so that you can monitor the traffic.</p>"},{"location":"at_commands/","title":"AT Command Reference","text":"<p>Each BlueSMiRF v2 firmware comes with a set of AT commands to read or change the configuration. The following set of AT commands are similar to previous BlueSMiRF AT commands. Let's go over some of these commands!</p>"},{"location":"at_commands/#at-commands","title":"AT Commands","text":"<p>Note</p> <p>Command mode cannot be entered 60 seconds after power-on or resetting. This setting can be configured with the command <code>AT-MaxCommandTimeMs</code>.</p> <p>BlueSMiRF radios are very flexible. By default, the radio is looking for serial communication at 115200 bps. Open the terminal of your choice. Then enter <code>$$$</code> and wait for an <code>OK</code>. Both the CONNECT and STATUS LEDs will fade in and fade out whenever the board is in Command Mode. At this point, the radio is now ready for an AT command.</p> BlueSMiRF v2 Connected to Serial Terminal and in Command Mode <p>Note</p> <p>Depending on your serial terminal's settings, you may not see the characters that are being sent. You can try turning on the local echo to view the characters. However, keep in mind that any characters sent when the BlueSMiRF v2 is in command mode will already be echoed back.</p> <p>Note</p> <p>The device can also be configured by connecting over Bluetooth and entering <code>$$$</code>.</p> <p>Below is a brief list of commands. The BlueSMiRF will recognize commands with capital and lower case letters since the commands are not case sensitive.</p> AT Command              Command Description              <code>$$$</code>                Enter Command Mode              <code>AT</code>                Reports OK              <code>AT?</code>                Display this help text              <code>ATA</code>                Display all settings              <code>ATB</code>                Display Bluetooth settings              <code>ATC</code>                Check for new firmware              <code>ATD</code>                Display the debug settings              <code>ATF</code>                Restore factory settings              <code>ATM</code>                Display MAC address              <code>ATP</code>                Start pairing process              <code>ATS</code>                Display serial settings              <code>ATU</code>                Update Firmware              <code>ATV</code>                Display firmware version              <code>ATW</code>                Save current settings to NVM              <code>ATX</code>                Exit command mode              <code>ATY</code>                Display system settings              <code>ATZ</code>                Reboot the system              <code>AT-Param=xxx</code>                Set parameter's value to xxx by name (Param)              <code>AT-Param?</code>                Print parameter's current value by name (Param)              <code>AT-?</code>                Display the setting values              AT Commands <p>A parameter is set using the AT- prefix, followed by the name of the command with an equals sign and the value to set. For example, sending AT-SerialSpeed=115200 followed by the ENTER key (or a carriage return) will change the serial interface speed to 115200bps. This setting can be stored in NVM (non-volatile memory) by sending the ATW command.</p> <p>To query a setting, send the AT command without a value and the device will respond with the current value. For example, sending AT-SerialSpeed followed by the ENTER key will generate the response 115200 followed by OK.</p> <p>The commands are best discussed in groups:</p> <ul> <li>Bluetooth Commands</li> <li>Serial Commands</li> <li>System Commands</li> </ul>"},{"location":"at_commands/#bluetooth-commands","title":"Bluetooth Commands","text":"<p>Below is a table for Bluetooth commands, a short description of the command, and its factory default value (if applicable). Right after the table, there is also a list which provides a detailed explanation of each parameter as well.</p> AT Command              Command Description              Factory Default Value              <code>AT-BluetoothConnectRetries</code>                Number of retries of a paired connection                             5              <code>AT-BluetoothConnectTimeoutMs</code>                Milliseconds before a paired connection attempt times out                             3000              <code>AT-BluetoothEscapeCharacter</code>                The character received from the remote system, sought to enter command mode              +              <code>AT-BluetoothNickname</code>                User configurable name to broadcast over Bluetooth during discovery                             \"BlueSMiRF-ABCD\", where ABCD is the last four hex digits of the Bluetooth MAC              <code>AT-BluetoothPairedMac</code>                MAC address of the unit that the user wants to connect to at startup              <code>AT-BluetoothPairedName</code>                Name of the unit that the user wants to connect to at startup              <code>AT-BluetoothPin</code>                Pin to enter during pairing - only required for older Bluetooth devices              1234              <code>AT-BluetoothRxSize</code>                Bluetooth receive buffer size                             2048              <code>AT-BluetoothTxSize</code>                Bluetooth write buffer size                             1024              <code>AT-BluetoothType</code>                Bluetooth protocol used for communication                             0              Bluetooth Commands <ul> <li> <p>BluetoothConnectRetries \u2014 If this device has a paired MAC or name, at power up it will attempt to connect to this paired device. A connection is not guaranteed, and the connection will be re-tried this number of times before going into passive, discoverable mode.</p> </li> <li> <p>BluetoothConnectTimeoutMs \u2014 When this device is connecting to a paired device, if this number of milliseconds expires before a connection is made, the device will attempt to reconnect to the paired device.</p> </li> <li> <p>BluetoothEscapeCharacter \u2014 This is the character that must be transmitted by a remote device to enter command mode remotely over the Bluetooth connection.</p> <p>Note</p> <p>Escape characters are ignored after <code>MaxCommandTimeMs</code> number of milliseconds and within <code>MinEscapeTimeMs</code> of other incoming characters.</p> </li> <li> <p>BluetoothNickname \u2014 The name that is broadcast when other devices are scanning for devices to pair to.</p> </li> <li> <p>BluetoothPairedMac \u2014 The MAC address of the BlueSMiRF that this device should pair to at power-on. Use the <code>ATM</code> command on the remote device to display its MAC address. This command is not normally used; use the button pairing method for an easier way to pair two devices.</p> </li> <li> <p>BluetoothPairedName \u2014 The name of the BlueSMiRF that this device should pair to at power-on. Use the <code>BluetoothNickname</code> command on the remote device to change its paired name. This command is not normally used; use the button pairing method for an easier way to pair two devices.</p> </li> <li> <p>BluetoothPin \u2014 The pin that is needed during pairing. Only needed on very old Bluetooth USB dongles.</p> </li> <li> <p>BluetoothRxSize \u2014 The size of the Bluetooth receive buffer. Increase if a large amount of data is coming into the BlueSMiRF over Bluetooth, before the speed of the serial interface can output it.</p> </li> <li> <p>BluetoothTxSize \u2014 The size of the Bluetooth transmit buffer. Increase if a large amount of data needs to be transmitted over Bluetooth but the connection between devices is poor and multiple retransmissions occur.</p> </li> <li> <p>BluetoothType \u2014 Controls the Bluetooth protocol. This parameter accepts a <code>0</code>, <code>1</code>, and <code>2</code> for the Bluetooth Protocol as listed below. Note that only the SPP protocol supports pairing.</p> <ul> <li>Protocol <code>0</code> = Serial Port Profile (SPP)</li> <li>Protocol <code>1</code> = Bluetooth Low-Energy (BLE)</li> <li>Protocol <code>2</code> = Radio off</li> </ul> </li> </ul>"},{"location":"at_commands/#serial-commands","title":"Serial Commands","text":"<p>Below is a table for serial commands, a short description of the command, and its factory default value (if applicable). Right after the table, there is also a list which provides a detailed explanation of each parameter as well.</p> AT Command              Command Description              Factory Default Value              <code>AT-FlowControl</code>                Enable the use of CTS/RTS flow control signals                             0              <code>AT-InvertCts</code>                Invert the input of CTS                             0              <code>AT-InvertRts</code>                Invert the output of RTS                             0              <code>AT-PartialFrameTimeoutMs</code>                Send partial buffer if time expires                             50              <code>AT-RtsStartSendingPercent</code>                Percent of serialReceiveBuffer that is free when RTS is asserted                             25              <code>AT-RtsStopSendingPercent</code>                Percent of serialReceiveBuffer that is free when RTS is deasserted                             5              <code>AT-SerialReceiveBufferSize</code>                Serial receive buffer size                             51200              <code>AT-SerialSpeed</code>                The baud rate that the BlueSmiRF operates at.                             115200              <code>AT-SerialTransmitBufferSize</code>                Buffer size to receive bytes from Bluetooth                             10240              Serial Commands <ul> <li> <p>FlowControl - If flow control is enabled, the BlueSMiRF v2 will send data when its CTS pin is driven low (the host system is telling the radio to transmit). If flow control is enabled, BlueSMiRF v2 will drive its RTS low if its serial buffer is full (the radio is telling the host system to hold its horses). By default, flow control is turned off.</p> </li> <li> <p>InvertCts - By default, InvertCts is false and CTS is high when data is allowed to flow. Enable InvertCts to do the opposite.</p> </li> <li> <p>InvertRts - By default, InvertRts is false and RTS is high when data is allowed to flow. Enable InvertRts to do the opposite.</p> </li> <li> <p>PartialFrameTimeoutMs - The number of milliseconds of timeout before a partial packet is sent. For example, if a partial frame of 12 bytes is received, the radio will wait this amount for more bytes before initiating a transmission.</p> </li> <li> <p>RtsStartSendingPercent - Percent of serialReceiveBuffer that is free when RTS is asserted. Default of 25% of serialReceiveBuffer.</p> </li> <li> <p>RtsStopSendingPercent - Percent of serialReceiveBuffer that is free when RTS is deasserted. Default of 5% of serialReceiveBuffer.</p> </li> <li> <p>SerialReceiveBufferSize - Buffer size to receive serial data from the serial port, to be sent over Bluetooth. The default is 51200.</p> </li> <li> <p>SerialSpeed - The baud rate that the BlueSMiRF operates at. Discrete values 2400, 4800, 9600, 14400, 19200, 38400, 57600, 115200 (default), 230400, 460800, and 921600bps are allowed.   </p> </li> <li> <p>SerialTransmitBufferSize - Buffer size to receive bytes from Bluetooth, waiting to be printed out the UART. The default is 10240.</p> </li> </ul>"},{"location":"at_commands/#system-commands","title":"System Commands","text":"<p>Below is a table for system commands, a short description of the command, and its factory default value (if applicable). Right after the table, there is also a list which provides a detailed explanation of each parameter as well.</p> AT Command              Command Description              Factory Default Value              <code>AT-EscapeCharacter</code>                The character sought to enter command mode                             $              <code>AT-EscapeCharacterCount</code>                The number of escape characters required to enter command mode                             3              <code>AT-LedStyle</code>                Controls the behavior of the Status and Connect LEDs                             0              <code>AT-MaxCommandTimeMs</code>                After this time in milliseconds, command mode cannot be entered                             60000              <code>AT-MinEscapeTimeMs</code>                Serial traffic must stop this amount of milliseconds before an escape character is recognized                              2000              <code>AT-WiFiPassword</code>                Password for the SSID, used for over-the-air-updates              <code>AT-WiFiSSID</code>                SSID used for over-the-air-updates              System Commands <ul> <li> <p>EscapeCharacter \u2014 The character that must be entered a number of times (<code>EscapeCharacterCount</code>) to enter configuration mode. An escape character must be entered before the max time of <code>MaxCommandTimeMs</code> and after <code>MinEscapeTimeMs</code>.</p> </li> <li> <p>EscapeCharacterCount \u2014 The number of escape characters needed before command mode is entered. Set to 0 to disable.</p> </li> <li> <p>LedStyle - Controls how the LEDs behave: CLASSIC = <code>0</code>, SERIAL_TRAFFIC = <code>1</code>, OFF = <code>2</code>.</p> <ul> <li> <p>CLASSIC mode (default) = <code>0</code> \u2014 The STATUS LED blinks with TX/RX traffic.</p> </li> <li> <p>SERIAL_TRAFFIC mode = <code>1</code> \u2014 The CONNECT LED blinks with TX traffic and the STATUS LED blinks with RX traffic.</p> </li> <li> <p>OFF mode = <code>2</code> \u2014 The CONNECT and STATUS LEDs are turned off.</p> </li> </ul> </li> <li> <p>MaxCommandTimeMs \u2014 Once this number of milliseconds has passed, command mode cannot be entered. This is used as a method to prevent a remote system from accidentally entering command mode.</p> </li> <li> <p>MinEscapeTimeMs \u2014 This number of milliseconds must pass between the last serial character received and an escape character. This is used as a method to prevent a remote system from accidentally entering command mode.</p> </li> <li> <p>WiFiPassword \u2014 The password for the local WiFi used for firmware updates.</p> </li> <li> <p>WiFiSSID \u2014 The SSID for the local WiFi used for firmware updates.</p> </li> </ul>"},{"location":"bluesmirf-v2_to_bluesmirf-v2/","title":"Example 1 - BlueSMiRF to BlueSMiRF","text":"<p>In this example, we will connect two BlueSMiRF v2 boards to two separate serial ports. We will then send characters from one serial terminal to a second serial terminal.</p> <p>The image below on the left shows the Serial Basic (CH340, USB-C) connected to the BlueSMiRF v2 Header using M/F jumper wires. Headers were used to easily remove and reconnect the BlueSMiRF v2 with headers. The image to the right shows the Serial Basic (CH340, micro-B) connected to the BlueSMiRF v2 PTH using M/F jumper wires. A row of female headers were soldered on the board. Extra long headers were placed between the female headers to easily remove and reconnect the BlueSMiRF v2 PTH as well.</p> USB-to-Serial Converter (CH340) to BlueSMiRF v2 Header with an Additional Stackable Header USB-to-Serial Converter (CH340) to BlueSMiRF v2 PTH <p>Note</p> <p>To distinguish between the two BlueSMiRFs, try labeling the two board. In this case, we chose had the one with male headers and the other one with female headers.</p> <p>Connect the first BlueSMiRF v2 to your computer's COM port. In this case, it was COM13. Press and hold the PAIR button between 4 to 8 seconds. The Status and Connect LEDs will slowly blink back and forth. The Connect LED will begin to fade in and out after a few seconds. Open a serial terminal and connect to the first BlueSMiRF at 115200 baud.</p> First Serial Terminal <p>At this point, connect the second BlueSMiRF v2 to your computer's COM port. In this case, it was COM18. Press and hold the second BlueSMiRF's PAIR button between 4 to 8 seconds. The second BlueSMiRF will scan the area for another BlueSMiRF and connect. Once connected, the Connect LEDs on both boards will remain solid. Open a second serial terminal, and connect to the second BlueSMiRF at 115200 baud. Move both serial terminals side by side.</p> Second Serial Terminal <p>Start typing characters in the first serial terminal. You should see them in the second serial terminal!</p> Sending Characters through First Terminal Receiving Characters through Second Terminal <p>Type a message in the second terminal window. You should see them in the first serial terminal!</p> Receiving Characters through First Serial Terminal Sending Characters through Second Terminal"},{"location":"bluesmirf-v2_to_smartphone/","title":"Example 2 - BlueSMiRF to Smartphone","text":"<p>Note</p> <p>Bluetooth classic (Serial Port Profile or SPP) is primarily supported. This Bluetooth protocol is supported on Android phones, most desktops, and laptops. The BlueSMiRF v2 also supports the BLE protocol, available on all Apple phones.</p> <p>In this example, we will connect a BlueSMiRF v2 to a smartphone and send serial data using the Bluetooth classic protocol (also known as Serial Port Profile or SPP).</p> <p>The image below shows the Serial Basic (CH340, USB-C) connected to the BlueSMiRF v2 Header using M/F jumper wires. Headers were used to easily remove and reconnect the BlueSMiRF v2 with headers.</p> BlueSMiRF v2 to SmartPhone Bluetooth Classic Serial Terminal"},{"location":"bluesmirf-v2_to_smartphone/#download-the-serial-bluetooth-terminal-app","title":"Download the Serial Bluetooth Terminal App","text":"<p>Head to your smartphone's app store. In this case, we were on an Android smartphone and used Google Play Store to download the Serial Bluetooth Terminal app. This app is great for development, debugging, and general use when using the BlueSMiRF's SPP and BLE protocols.</p> Google Play: Serial Bluetooth Terminal <p>Note</p> <p>If you have a different phone OS, there are many apps like the Serial Bluetooth Terminal available for different smartphones. Just do a search in your app store.</p>"},{"location":"bluesmirf-v2_to_smartphone/#pair-the-bluesmirf-v2-with-your-smartphone","title":"Pair the BlueSMiRF v2 with your Smartphone","text":"<p>Once downloaded, turn on your Bluetooth and open your Bluetooth settings. Scroll down until you see the available devices. With BlueSMiRF powered up and in range, you should be able to see the device in discoverable mode listed as BlueSMiRF-ABCD, where ABCD is the last four hex digits of the Bluetooth MAC. In this case, it was BlueSMiRF-5A66.</p> BlueSMiRF Discovered on Android Smartphone <p>Click on the device to begin pairing. A message will pop up asking if you want to pair with the device. At this point, select \"Pair.\"</p> BlueSMiRF Discovered on Android Smartphone <p>Scroll up to your Paired devices and look for the BlueSMiRF to verify that it has paired with your phone.</p> BlueSMiRF-5A66 Showing Up as a Paired Bluetooth Device"},{"location":"bluesmirf-v2_to_smartphone/#sending-characters-between-a-bluesmirf-and-smartphone","title":"Sending Characters Between a BlueSMiRF and Smartphone","text":"<p>Open the Serial Bluetooth Terminal app.</p> Serial Bluetooth Terminal Opened <p>Click on the connect icon to the left of the trash can icon. If all is well, you will get a message indicating that the BlueSMiRF is connected.</p> Connected to BlueSMiRF-5A66 <p>Open a serial terminal, and connect to the BlueSMiRF at 115200 baud. In this case, it was connected to COM13. Start typing characters in the serial terminal. You should see them in the Serial Bluetooth Terminal app!</p> Serial Terminal Connected to BlueSMiRF v2 Receiving Characters through the Serial Bluetooth Terminal  <p>Type a message and send them using the Serial Bluetooth Terminal app. You should see the message in the serial terminal!</p> Receiving Characters through First Serial Terminal Sending Characters through Serial Bluetooth Terminal <p>Sending serial data between the BlueSMiRF and smartphone using the Serial Bluetooth Terminal app is only the start! For example, you can use BlueSMiRF v2 and a smartphone to send/receive correction data to/from a high precision GNSS module. Try looking at the following methods to send data between the BlueSMiRF v2 and a smartphone. Just make sure to adjust the baud rate of the BlueSMiRF to match the high precision GNSS module's baud rate (for the u-blox modules, the correction port's default is typically set to 38400 baud). These are only a few ways to connect a high precision GNSS module to your smartphone's GNSS app to achieve an RTK Fixed Mode.</p> <ul> <li>Connecting the ZED-F9P to a Correction Source using an NTRIP Client</li> <li>Setting the ZED-F9P as a Correction Source</li> </ul>"},{"location":"button/","title":"Button Control","text":"<p>The PAIR button on the BlueSMiRF v2 allows the device to enter a few different states.</p> <ul> <li>Pairing Mode</li> <li>Factory Reset Mode</li> <li>Bootloader Mode</li> </ul>"},{"location":"button/#pairing-mode","title":"Pairing Mode","text":"<p>Pairing mode is used to connect two BlueSMiRF v2 devices for direct communication. This mode is not needed for general discovery; a phone or a laptop can simply discover the BlueSMiRF v2 in its default state.</p> <p>Holding the Pair button between 4 to 8 seconds will cause the Status and Connect LEDs to slowly blink back and forth. If the Pair button is released at this time, the device will enter Pairing mode.</p> GIF Setting BlueSMiRF v2 in Pairing Mode  <p>Generally speaking, to create a serial bridge between two BlueSMiRFs, one device needs to be in discoverable mode and the other device needs to discover it. This means, one device needs to have its Pair button held for 4 to 8 seconds then released. It will then fail to discover any compatible devices then enter Discoverable mode. Once this is done, the second device needs to have its Pair button held for 4 to 8 seconds, then released. The second device will then scan and discover the first device and pair with it. From this point on, the second device will always try to connect to the first device at power on.</p> <p>Once a BlueSMiRF has entered Pairing Mode, it will scan for other compatible BlueSMiRF devices. If no other compatible device is found after a few seconds, the BlueSMiRF will enter Discoverable mode. The device will broadcast the name 'BlueSMiRF-Pairing' and wait for an incoming connection.</p> <p>If a second device enters Pairing Mode, it will scan for other compatible BlueSMiRF devices broadcasting the name (you guessed it) 'BlueSMiRF-Pairing'. If a device is detected, the second device will connect to the first device, store the MAC address of the first device, and attempt to connect to it at every future power on. The first device will not be aware of or connect to the first device at power on.</p>"},{"location":"button/#factory-reset-mode","title":"Factory Reset Mode","text":"<p>Holding the Pair button for more than 8 seconds will cause the Status and Connect LEDs to quickly blink back and forth. If the Pair button is released at this time, the device will enter Factory Reset mode.</p> GIF Factory Reset <p>After a Factory Reset, all settings are reset to default and/or erased in the following way:</p> <ul> <li>The baud rate is set to 115200 bps.</li> <li>The escape character is set to '<code>$</code>' and a count of 3.</li> <li>The WiFi SSID and password are erased.</li> <li>Flow control is disabled.</li> <li>All the other system settings are returned to default.</li> </ul>"},{"location":"button/#bootloader-mode","title":"Bootloader Mode","text":"<p>Hold down the PAIR button when the BlueSMiRF v2 is not powered. Applying power will set the microcontroller to bootloader mode. The STATUS LED will be dim indicating that we are in Bootloader Mode. After uploading the firmware binaries to the ESP32, you will need to cycle power to the device as this does not automatically exit the bootloader mode.</p> GIF Setting the BlueSMiRF in Bootloader Mode <p>Note</p> <p>As stated in the hardware hookup when connecting a USB-to-serial converter, you will need to manually wire the TX-to-RX and RX-to-TX to a USB-to-serial converter with jumper wires.</p>"},{"location":"firmware_update/","title":"Firmware Update","text":"<p>From time to time, SparkFun will release new firmware for the BlueSMiRF v2 product line to add and improve functionality.  For most users, firmware can be upgraded over a 2.4GHz WiFi network using the OTA method. Users can also update the firmware manually using a Command Line Interface (CLI)</p>"},{"location":"firmware_update/#updating-firmware-over-the-air-ota","title":"Updating Firmware Over-The-Air (OTA)","text":"<p>Once the <code>AT-WiFiSSID</code> and <code>AT-WiFiPassword</code> settings have been entered for your local WiFi network, the <code>ATC</code> command can be issued to check for new firmware. If new firmware is available, send the <code>ATU</code> command to begin an update.</p>"},{"location":"firmware_update/#manually-updating-firmware-over-serial","title":"Manually Updating Firmware Over Serial","text":"<p>Because it's much easier to use, we recommend the OTA firmware update process. If that fails for some reason, the following CLI method can be used.</p>"},{"location":"firmware_update/#entering-bootloader-mode","title":"Entering Bootloader Mode","text":"<p>Hold the PAIR button while powering the BlueSMiRF v2. This will cause the ESP32 to enter bootloader mode. Once the BlueSMiRF v2 is in bootloader mode, the STATUS LED will be dimly lit and the CONNECT LED will be off.</p> <p>We recommend using a breadboard or jumper wires to connect the BlueSMiRF to a USB-to-Serial connection. At a minimum, you will need to connect the UART pins, power, and ground as stated in the hardware hookup. Remember, the TX and RX connections must be crossed over.</p> USB-to-Serial ConverterPinout              Intermediate Wire Connection BlueSMiRF v2Pinout              DTR RTS RXI RXI TXO TXO 3V3 VCC CTS CTS GND GND <p>Note</p> <p>The connection also includes two additional connections for flow control: RTS and CTS. These two connections are not needed for a basic serial UART connection. However, using all six wires can help make a tighter connection on the 1x6 header. The wire colors also connect TXO-to-RXI and RXI-to-RXO to indicate that it is not a direct connection between the two boards and the 1x6 header.</p> USB-to-Serial Converter (CH340) to BlueSMiRF v2 Header with an Additional Stackable Header"},{"location":"firmware_update/#windows","title":"Windows","text":"<p>Identify the COM port the USB-to-Serial device enumerated at. The easiest way to do this is to open the Device Manager under the Ports (COM &amp; LPT) tree:</p> CH340 is on COM10 as shown in Device Manager <p>If the COM port is not showing, be sure the unit is turned On. If an unknown device is appearing, you\u2019ll need to install drivers for your USB-to-serial device (we'll assume that you are using the CH340).</p> <p>Once the correct COM port is identified, head to the GitHub repo for the BlueSMiRF v2 binaries and download all the contents. Unzip the contents in a known directory and copy the path.</p> Download BlueSMiRF v2 Binaries GitHub Repo (ZIP) <p>Open a command prompt (Windows button + r then type \u2018 cmd \u2019). Head to the directory where you unzipped the folder. You'll need to use the <code>cd</code> commmand, paste the path where you unzipped the folder, and hit the enter key.</p> Change Path to BlueSmiRF Binaries Folder <p>You'll then need to run the 'batch_program.bat' along with the binary file name and COM port. Enter the following command below, where COM4 should be replaced by the COM port you identified earlier and BlueSMiRF_Firmware_v1_0.bin is the firmware that you are updating to. Make sure to send an additional key to run the batch file.</p> <pre><code>batch_program.bat BlueSMiRF_Firmware_v1_0.bin COM4\n</code></pre> batch_program.bat running esptool <p>After about 20 seconds, you should see the following message: <code>Done programming! Ready for next board.</code></p> Successfully Programmed BlueSMiRF v2 - ESP32 <p>The batch file runs the following commands, where COM4 is replaced with the COM port that the BlueSMiRF product enumerated at and BlueSMiRF_Firmware_vx_x.bin is the firmware you would like to load.</p> <pre><code>esptool.exe --chip esp32 --port COM4 --baud 921600 --before default_reset --after hard_reset write_flash -z --flash_mode dio --flash_freq 80m --flash_size 8MB 0x1000 bins/bootloader.bin 0x8000 bins/partitions.bin 0xe000 bins/boot_app0.bin 0x10000 BlueSMiRF_Firmware_v1_0.bin\n</code></pre> <p>Note</p> <p>Some users have reported the <code>921600</code> baud rate does not work. Decrease this to <code>115200</code> as needed.</p> <p>Tip</p> <p>Finished programming the ESP32? Type CTRL + C , Y , and ENTER to exit the batch file. You can also close the window.</p> <p>Upon completion, the BlueSMiRF v2 must be power cycled to exit bootloader mode. Once power cycled, the BlueSMiRF will start running the new firmware.</p> <p>Note</p> <p>We recommend disconnecting the USB cable from the USB-to-Serial Converter or your computer's COM port.</p>"},{"location":"firmware_update/#macos-linux","title":"macOS / Linux","text":"<p>Get esptool.py. Connect a USB A to C cable from your computer to the USB-to-Serial. Now identify the COM port the USB-to-serial device enumerated at.</p> <p>If the COM port is not showing, be sure the unit is turned On. If an unknown device is appearing, you\u2019ll need to install drivers for your USB-to-serial device (we'll assume that you are using the CH340).</p> <p>Once the correct COM port is identified, head to the GitHub repo for the BlueSMiRF v2 binaries and download all the contents. Unzip the contents in a known directory and copy the path.</p> Download BlueSMiRF v2 Binaries GitHub Repo (ZIP) <p>Open a Terminal window and run the following command, where /dev/ttyUSB0 is replaced with the port that the USB-to-Serial board enumerated at and BlueSMiRF_Firmware_vx_x.bin is the firmware you would like to load.</p> <pre><code>py esptool.py --chip esp32 --port /dev/ttyUSB0 --baud 921600 --before default_reset --after hard_reset write_flash  -z --flash_mode dio --flash_freq 80m --flash_size 8MB 0x1000 bins/bootloader.bin 0x8000 bins/partitions.bin 0xe000 bins/boot_app0.bin 0x10000 BlueSMiRF_Firmware_vx_x.bin\n</code></pre> <p>Note</p> <p>Some users have reported the <code>921600</code> baud rate does not work. Decrease this to <code>115200</code> as needed.</p> <p>Tip</p> <p>Finished programming the ESP32? Type CTRL + C , Y , and ENTER to exit the batch file. You can also close the window.</p> <p>Upon completion, the BlueSMiRF must be power cycled to exit bootloader mode. Once power cycled, the BlueSMiRF will start running the new firmware.</p> <p>Note</p> <p>We recommend disconnecting the USB cable from the USB-to-Serial Converter or your computer's COM port.</p>"},{"location":"hard_copy/","title":"Hard copy","text":"<p>Need to download or print our hookup guide?</p> <ul> <li>Print  (Single-Page View)<ul> <li>To save as a <code>*.pdf</code> file, select the Printer or Destination labeled Save as PDF. (Instructions will vary based on the browser)</li> </ul> </li> </ul>"},{"location":"hardware_hookup/","title":"Hardware Hookup","text":"<p>In this section, we'll go over how to connect to the BlueSMiRF v2.</p>"},{"location":"hardware_hookup/#connecting-via-bluesmirf-v2-pth","title":"Connecting via BlueSMiRF v2 PTH","text":"<p>For a temporary connection to the PTH BlueSMiRF v2, you could use IC hooks to test out the pins. However, you'll need to solder headers or wires of your choice to the board for a secure connection. You can choose between a combination of header pins and jumper wires, or stripping wire and soldering the wire directly to the board.</p> <ul> <li> <p> </p> <p> How to Solder: Through Hole Soldering </p> </li> </ul> <ul> <li> <p> </p> <p> Working with Wire </p> </li> </ul>"},{"location":"hardware_hookup/#basic-serial-uart-connection","title":"Basic Serial UART Connection","text":"<p>At a minimum, you will need to connect serial TX, serial RX, power, and ground for a basic serial UART connection. This connection is needed to send serial data between the two UART devices, configure settings, or even manually upload binaries to the ESP32. Between each serial device, always make sure to cross the RX and TX lines between serial devices (i.e. RX-to-TX and TX-to-RX). The table indicates below shows color cells being the same for the TXO-to-RXI and RXI-to-TXO. Note that the order of the pins may be different depending on the design, so you may not be able to make a direct connection with the BlueSMiRF v2's 1x6 header.</p> Serial DevicePinout              BlueSMiRF v2Pinout              TXO RXI RXI TXO 3V3 VCC GND GND <p>Note</p> <p>In some cases, you may only need to just wire one serial wire from your serial device to the BlueSMiRF.</p>"},{"location":"hardware_hookup/#usb-to-serial-converter-to-bluesmirf-v2","title":"USB-to-Serial Converter to BlueSMiRF v2","text":"<p>Depending on the USB-to-serial converter that you choose, you may need to install drivers. If you've never connected an FTDI or CH340 to your computer before, you may need to install drivers for the USB-to-serial converter. Check out our How to Install FTDI Drivers or How to Install CH340 Drivers tutorial for help with the installation.</p> <ul> <li> <p> </p> <p> How to Install FTDI Drivers </p> </li> </ul> <ul> <li> <p> </p> <p> How to Install CH340 Drivers </p> </li> </ul> <p>To make a connection to a USB-to-serial converter, you will need a basic serial connection. There are several converters available such as the FT232 or CH340. Each of these boards include a different USB connector. You will need to manually wire them up using jumper wires as shown in the table and image below.</p> USB-to-Serial ConverterPinout              Intermediate Wire Connection BlueSMiRF v2Pinout              DTR RTS RXI RXI TXO TXO 3V3 VCC CTS CTS GND GND <p>Note</p> <p>The connection also includes two additional connection for flow control: RTS and CTS. These two connections are not needed for a basic serial UART connection. However, using all six wires can help make a tighter connection on the 1x6 header. The wire colors also connect TXO-to-RXI and RXI-to-TXO to indicate that it is not a direct connection between the two boards and the 1x6 header.</p> <p>Below is one example between the serial basic breakout (CH340, USB-C) and the BlueSMiRF v2 Header. Male to female jumper wires were connected between the boards.</p> USB-to-Serial Converter (CH340) to BlueSMiRF v2 Header with TX-to-RX and RX-to-TX <p>Adding a simple 1x6 stackable header between the jumper wires will make a quick adapter with the M/F jumper wires and USB-to-serial converter. You'll just need to match the DTR and GND pins. This is useful for those that need to constantly configure the BlueSMiRF v2's settings and re-reconnect to a USB-to-serial converter.</p> USB-to-Serial Converter (CH340) to BlueSMiRF v2 Header with an Additional Stackable Header <p>Tip</p> <p>To make it easier to connect visually, try adding a polarity marker with whiteout, Sharpie, or paint. You can even try rotating one of the jumper wires so that the metal tabs is not facing the same direction on one or both ends.</p> <p>Remember, for those that are using the PTH version, you will need to solder either male headers, female headers, or wires. The type of header or wire will depend on your personal preference and project needs. In this case, we used a 1x6 female header to the board. At the time of writing, there were only female to male jumper wires available so extra long headers were placed between the female header pins. The male header was connected to another serial basic (CH340).</p> USB-to-Serial Converter (CH340) to BlueSMiRF v2 PTH"},{"location":"hardware_hookup/#bluesmirf-v2-to-standard-serial-uart-port","title":"BlueSMiRF v2 to Standard Serial UART Port","text":"<p>For boards that already include the footprint for a standard serial UART port, you can connect directly to the pins. You will find these on a few Arduino development boards. The Arduino Pro, Arduino Pro Mini, and LilyPad Arduino 328 Main Board are just a few boards that have the standard port. You will also notice certain boards will have the standard serial UART port labeled as the RTCM Correction Port on SparkFun high precision GNSS breakout boards. For certain boards that have a male header soldered, you may need to consider soldering a 1x6 female header on the BlueSMiRF v2 PTH.</p> BlueSMiRF v2 Replacing Serial Connection on the Arduino Pro Mini 3.3V Serial Header Port BlueSMiRF v2 Connected to the ZED-F9P's RTCM Correction Port UM980 with the BlueSMiRF v2 Connected to the UM980's RTCM Correction Port <p>Note</p> <p>There are older boards that may have a serial port labeled as BlueSMiRF. You will need to wire the connection manually with jumper wires. One example is the SparkFun Arduino ProtoShield where the board uses the older BlueSMiRF pinout. There are jumpers that you can cut on the board and additional PTHs to rewire the pins if you decide to connect directly to the 1x6 header.</p> <p> SparkFun Arduino ProtoShield Serial Port Highlighted </p>"},{"location":"hardware_overview/","title":"Hardware Overview","text":"<p>In this section, we will highlight the hardware and pins that are broken out on the SparkFun BlueSMiRF v2. For the scope of the tutorial, we will be referring to the version with the headers.</p> SMD with Headers, Top View SMD with Headers, Bottom View <p>There is also a version with PTHs out in the wild and it is essentially the same. The only differences are that the pins are broken out to PTHs instead of a SMD right angle male header and the silkscreen labels.</p> PTH Version, Top View PTH Version, Bottom View <p>For more information, check out our Resources and Going Further for the board designs and the ESP32.</p>"},{"location":"hardware_overview/#esp32-pico-mini-02","title":"ESP32-PICO-MINI-02","text":"<p>The board includes the smaller ESP32-PICO-MINI-02 module from Espressif. The SparkFun BlueSMiRF v2 is perfect for short range applications that require point-to-point communication. We've written some firmware to allow serial UART data to be sent between two Bluetooth devices. The supported protocols include SPP and BLE. Testing a pair of BlueSMiRF v2s and we got about ~110 feet (~33m) in the SparkFun building. The TX (10k) and RX (50k) buffers are also very large to allow for radio delays. The included firmware also includes a set of AT commands to configure the ESP32. This includes the baud rate, flow control, LED mode, and Over-The-Air (OTA) updates over a 2.4GHz WiFi network to name a few. You can also manually reprogram the ESP32 module using the command line interface as well! Just make sure to connect Tx and Rx between the BlueSMiRF and a USB-to-serial converter.</p>"},{"location":"hardware_overview/#power","title":"Power","text":"<p>Power is broken out on the 1x6 header through the VCC and GND pins. The recommended input voltage can be between 3.3V to 5V. Logic level shifting circuitry is included on the TX and RX pins so that they are 3.3V to 5V tolerant.</p> <ul> <li>VCC / 3V3-5V \u2014 On the top of the board, the input voltage is labeled as VCC. On the back of the board, this is labeled as 3V3-5V. Voltage is regulated down with the AP2112K 3.3V/600mA voltage regulator from this pin. Typically, one would apply either 3.3V or 5V to this pin. Make sure that power you provide to this pin does not exceed 6 volts. For advanced users, you can bypass this voltage regulator by adding a solder blob on the jumper labeled as JP2. Be careful as the input voltage range is smaller and you may run the risk of damaging the ESP32.</li> <li>GND \u2014 Of course, is the common, ground voltage (0V reference) for the system.</li> </ul> Power, Top View Power, Bottom View <p>The current and power consumption depends on what it's doing at the time. Here are some of our results after measuring the current and power consumption at 3.3V. The module can get toasty when pushing serial traffic through but not scary-burn-you-hot.</p> <ul> <li>Idle: 72mA / 238mW</li> <li>Connected with no Serial Traffic: 75mA / 248mW</li> <li>Constant Duplex Serial Traffic: 140mA / 462mW</li> </ul> <p>Note</p> <p>There are also test points on the back of the board that are not labeled for VCC and GND. These are not labeled and are used by SparkFun's production for testing &amp; programming the board using test beds.</p>"},{"location":"hardware_overview/#reset","title":"Reset","text":"<p>The reset PTH labeled as RST will restart the ESP32 whenever the pin is grounded.</p> Reset, Top View Reset, Bottom View"},{"location":"hardware_overview/#serial-uart-port","title":"Serial UART Port","text":"<p>Note</p> <p>As stated in the previous section, the pinout of the BlueSMiRF v2 is different from previous BlueSMiRFs, hence the version 2. Besides the ESP32 module, the pinout has the same pinout as previous Bluetooth Mates and USB-to-serial converters (i.e. FTDI, CH340, etc.). The board is meant to connect directly with an Arduino Pro, Pro Mini, RTCM Correction Ports on high precision GNSS breakout boards, or any board with a standard serial-to-USB port. Below is the back of the Bluetooth Mate, BlueSMiRF, and BlueSMiRF v2 boards.</p> <p> Back of Bluetooth Mate, BlueSMiRF, and BlueSMiRF v2 </p> <p>Both boards include a standard serial UART header seen on many USB-to-serial converters: RTS/RXI/TXO/VCC/CTS/GND. Depending on the version that you purchase, one will be PTH while the other includes right angle male headers. Due to spacing, the PTH version will also have slightly different silkscreen labels.</p> <ul> <li>RTS / RT \u2014 The Ready to Send is an output and is used for hardware flow control in some serial interfaces. This output is not critical for simple serial communication. If flow control is enabled, BlueSMiRF will drive its RTS low if its serial buffer is full (the radio is telling the host system to hold its horses). <li>RXI / RI \u2014 The serial receive is an input. This input pin receives serial data from another serial device. Logic level circuitry is included on this pin. It should be connected to the TX of the other device.</li> <li>TXO / TO \u2014  The serial transmit is an output. This output pin sends serial data to another device. Logic level circuitry is included on this pin. It should be connected to the RX of the other device.</li> <li>VCC/ V / 3V3-5V \u2014 This input voltage supply signal is routed through a AP2112K voltage regulator and brought down 3.3V for the ESP32. We will assume that it is attached to another device's standard serial port and it is providing power to the BlueSMiRF v2. As stated earlier, the recommended input voltage is between 3.3V to 5V.</li> <li>CTS / CT \u2014 The Clear to Send is an input. CTS is another serial flow control signal. Like RTS, it's not required for most, simple serial interfaces. If flow control is enabled, BlueSMiRF will send data when its CTS pin is driven low (the host system is telling the radio that it's ready for more serial data).</li> <li>GND / G \u2014 The 0V reference voltage, common to any other device connected to the Bluetooth modem.</li> Serial Header, Top View Serial Header, Bottom View PTH Serial Header, Top View PTH Serial Header, Bottom View <p>Tip</p> <p>For those that are connecting to the old school RS232 serial port, you will need a RS232 to TTL converter for higher voltages. The RS232 to TTL converter can handle larger voltages designed for RS232.</p> <p> SparkFun RS232 Shifter - SMD       PRT-00449 </p>"},{"location":"hardware_overview/#button","title":"Button","text":"<p>The PAIR button is more than meets the eye. This button has more than one function depending on how long it is pushed down.</p> <ul> <li>Short Push \u2014 Press and hold the button down between 4 to 8 seconds will initiate pairing with another Bluetooth device. During that period of time, the Status and Connect LEDs will slowly blink back and forth. When the BlueSMiRF v2 fails to discover any compatible devices, it will enter Discoverable mode.</li> <li>Long Push \u2014 Press and hold the down for more than 8 seconds to set the ESP32 back to its factory default settings.</li> </ul> <p>Note</p> <p>Users can also set the BlueSMiRF v2 in bootloader mode. In this mode, you can update the firmware manually through serial using a command line interface. Users will need to hold down the PAIR button when the BlueSMiRF v2 is not powered. Applying power will put the microcontroller into bootloader mode.</p> <p>For more information about using the button for each mode, check out the section about the button control.</p> Button Control"},{"location":"hardware_overview/#leds","title":"LEDs","text":"<p>The board includes the following status LEDs as indicated in the image below.</p> <ul> <li>CONNECT \u2014 The connect LED indicates when the ESP32 is connected to another Bluetooth device. The behavior of the LED will depend on the mode:<ul> <li><code>0</code> \u2014 By default, the CONNECT LED will blink until it is connect to another Bluetooth device. Once connected, this LED will remain solid.</li> <li><code>1</code> \u2014 When set to a <code>1</code>, the CONNECT LED will blink until it is connected to another Bluetooth device. Once connected, this LED will blink with TX traffic.</li> </ul> </li> <li>STATUS \u2014 The status LED indicates when there is UART traffic. The behavior of the LED will depend on the mode.<ul> <li><code>0</code> \u2014 By default, the STATUS LED blinks with any TX/RX traffic.</li> <li><code>1</code> \u2014 When set to a <code>1</code>, the STATUS LED blinks with only the RX traffic.</li> </ul> </li> </ul> <p>The LEDs can also blink at different rates, fade, or become dim when the PAIR button is held down. This is used as an indicator to tell when we are entering pairing, factory reset, or bootloader mode. For more information, check out the section about the button control.</p> Button Control"},{"location":"hardware_overview/#jumpers","title":"Jumpers","text":"<p>Note</p> <p>If this is your first time working with jumpers, check out the How to Work with Jumper Pads and PCB Traces tutorial for more information.</p> <p>The board includes the following jumpers on the top and bottom of the board.</p> <ul> <li>JP2 \u2014 Jumper pad 2 is open by default. This jumper is used to bypass the 3.3V voltage regulator. Add a solder blob to close the jumper to connect VCC to 3.3V.</li> <li>BTN \u2014 The button jumper are closed by default. This connects the pair button to GPIO pin 0. Cut this jumper to disable the button.</li> </ul> Jumpers, Top View Jumpers, Bottom View"},{"location":"hardware_overview/#3d-model","title":"3D Model","text":"<p>A 3D model of the SparkFun BlueSMiRF v2 SMD and components was exported to STEP file using KiCad.</p> <p></p> Click Here for the STEP File <p>A 3D model of the SparkFun BlueSMiRF v2 PTH and components was also exported to STEP file using KiCad.</p> <p></p> Click Here for the STEP File"},{"location":"hardware_overview/#board-dimensions","title":"Board Dimensions","text":"<p>Each version of the board is 38.1mm x 15.2mm. Note that the version with the headers makes the board slightly longer by making the overall length 44.2mm. Adding a row of female 1x6 headers or jumper wires will increase the length slightly as well. There are no mounting holes for standoffs on the boards.</p> Board Dimensions for PTH, without Headers Board Dimensions for SMD with Headers"},{"location":"introduction/","title":"Introduction","text":"<p>The SparkFun BlueSMiRF v2 is a wireless Bluetooth\u00ae serial link. This version of the popular BlueSMiRF uses the ESP32. These boards work as a wireless serial UART pipe and are a great wireless replacement for serial cables. Simply pair, connect, and transmit serial data between your TX/RX lines! Any serial stream from 2400 to 921600 baud can be passed seamlessly between two devices.</p> <p> <ul> <li> <p> </p> <p> SparkFun BlueSMiRF v2    WRL-24113    Purchase from SparkFun  </p> </li> </ul> <ul> <li> <p> </p> <p> SparkFun BlueSMiRF v2 - Headers    WRL-23287    Purchase from SparkFun  </p> </li> </ul> <p></p> <p>In this tutorial, we'll go over the hardware and how to hookup the breakout board. We will also go over how to connect to a smartphone and a basic Arduino example to get started!</p>"},{"location":"introduction/#required-materials","title":"Required Materials","text":"<p>To follow along with this tutorial, you will need the following materials. You may not need everything though depending on what you have. Add it to your cart, read through the guide, and adjust the cart as necessary. We recommend the board with headers to minimize the amount of soldering to your application.</p> <ul> <li>2x SparkFun BlueSMiRF v2 - Headers [WRL-23287]</li> <li>2x Jumper Wires Premium 6\" M/F Pack of 10 [PRT-09140]</li> <li>2x SparkFun Serial Basic Breakout - CH340C and USB-C [DEV-15096]</li> <li>2x Reversible USB A to C Cable - 0.8m [CAB-15425]</li> </ul> <ul> <li> <p> </p> <p> SparkFun BlueSMiRF v2 - Headers    WRL-23287 </p> </li> </ul> <ul> <li> <p> </p> <p> Jumper Wires Premium 6\" M/F Pack of 10    PRT-09140 </p> </li> </ul> <ul> <li> <p> </p> <p> SparkFun Serial Basic Breakout - CH340C and USB-C    DEV-15096 </p> </li> </ul> <ul> <li> <p> </p> <p> Reversible USB A to C Cable - 0.8m    CAB-15425 </p> </li> </ul>"},{"location":"introduction/#tools-optional","title":"Tools \u00a0(Optional)","text":"<p>You will need a soldering iron, solder, and general soldering accessories for a secure connection when using the plated through holes. You may also need to solder headers or wires to any devices that the BlueSMiRF v2 is connecting to.</p> <ul> <li>Soldering Iron [TOL-14456]</li> <li>Solder Lead Free - 15-gram Tube [TOL-9163]</li> <li>Flush Cutters - Xcelite [TOL-14782]</li> <li>Hook-Up Wire - Assortment (Stranded, 22 AWG) [PRT-11375]</li> <li>Wire Strippers - 20-30 AWG [TOL-24771]</li> </ul> <ul> <li> <p> </p> <p> Soldering Iron - 60W (Adjustable Temperature)    TOL-14456 </p> </li> </ul> <ul> <li> <p> </p> <p> Solder Lead Free - 15-gram Tube    TOL-09163 </p> </li> </ul> <ul> <li> <p> </p> <p> Hook-Up Wire - Assortment (Stranded, 22 AWG)    PRT-11375 </p> </li> </ul> <ul> <li> <p> </p> <p> Wire Strippers - 20-30 AWG    TOL-24771 </p> </li> </ul> <ul> <li> <p> </p> <p> Flush Cutters - Xcelite    TOL-14782 </p> </li> </ul>"},{"location":"introduction/#prototyping-accessories-optional","title":"Prototyping Accessories \u00a0(Optional)","text":"<p>For those using the PTH version, you will need to connect to the PTHs. You could use IC hooks and a breadboard for a temporary connection depending on your setup and what you have available. Of course, you will want to the solder header pins for a secure connection. We'll assume that you will want to solder a female header since there is already a BlueSMiRF v2 with the male headers available. Then again, you can still solder wire or even your own male headers if you prefer. Below are a few prototyping accessories that you may want to consider.</p> <ul> <li>Breadboard - Self-Adhesive (White) [PRT-12002]</li> <li>IC Hook with Pigtail [CAB-09741]</li> <li>Header - 6-pin Female (PTH, 0.1\") [PRT-11894]</li> <li>Arduino Stackable Header - 6 Pin [PRT-09280]</li> <li>Break Away Headers - Straight [PRT-00116]</li> <li>Break Away Headers - 40-pin Male (Long Centered, PTH, 0.1\") [PRT-12693]</li> <li>Jumper Wires Premium 6\" M/F Pack of 10 [PRT-09140]</li> <li>Jumper Wires Premium 6\" F/F Pack of 10 [PRT-08430]</li> </ul> <ul> <li> <p> </p> <p> Breadboard - Self-Adhesive (White)    PRT-12002 </p> </li> </ul> <ul> <li> <p> </p> <p> IC Hook with Pigtail    CAB-09741 </p> </li> </ul> <ul> <li> <p> </p> <p> Female Headers    PRT-11894 </p> </li> </ul> <ul> <li> <p> </p> <p> Arduino Stackable Header - 6 Pin    PRT-09280 </p> </li> </ul> <ul> <li> <p> </p> <p> Break Away Headers - Straight    PRT-00116 </p> </li> </ul> <ul> <li> <p> </p> <p> Break Away Headers - 40-pin Male (Long Centered, PTH, 0.1\")    PRT-12693 </p> </li> </ul> <ul> <li> <p> </p> <p> Jumper Wires Premium 6\" M/F Pack of 10    PRT-09140 </p> </li> </ul> <ul> <li> <p> </p> <p> Jumper Wires Premium 6\" M/M Pack of 10    PRT-08431 </p> </li> </ul> <ul> <li> <p> </p> <p> Break Away Male Headers - Right Angle    PRT-00553 </p> </li> </ul>"},{"location":"introduction/#you-will-also-need","title":"You Will Also Need","text":"<p>Depending on your setup or what you are doing, you may need the following as well.</p> <ul> <li>2.4GHz WiFi Network for firmware updates</li> <li>Smartphone with an Internet Service</li> </ul>"},{"location":"introduction/#suggested-reading","title":"Suggested Reading","text":"<p>If you aren\u2019t familiar with the following concepts, we also recommend checking out a few of these tutorials before continuing.</p> <ul> <li> <p> </p> <p> Bluetooth Basics </p> </li> </ul> <ul> <li> <p> </p> <p> Serial Terminal Basics </p> </li> </ul> <ul> <li> <p> </p> <p> Serial Communication </p> </li> </ul> <ul> <li> <p> </p> <p> How to Solder: Through-Hole Soldering </p> </li> </ul> <ul> <li> <p> </p> <p> Logic Levels </p> </li> </ul>"},{"location":"old_school_to_new_school/","title":"Old School to New School","text":"<p>Before we go over the hardware though, let's compare previous SparkFun BlueSMiRF versions with the BlueSMiRF v2!</p> <p>Back in April 2005, we originally released the BlueSMiRF v1 (short for Bluetooth Serial Miniature RF Link version 1) with BlueRadio's WML-C40AH. They came in two flavors: one with 4-pins for the basic BlueSMiRF consisting of PWR/GND/TX-O/RX-I, and the other with 6-pins for the extended BlueSMiRF consisting of RTS/RX-I/TX-O/GND/PWR/CTS. Over the years, the extended 1x6 pin became the \"standard\" for the BlueSMiRF.</p> Basic BlueSMiRF Extended BlueSMiRF <p>We even saw changes in the Bluetooth modems! The BlueRadio's WML-C40AH modems eventually switched over to Roving Network's RN-41 and RN-42. Each version had different ranges and transmit power.</p> BlueSMiRF Gold (RN-42) BlueSMiRF Silver (RN-41) <p>The 1x6 pins also were rearranged for the SparkFun Bluetooth Mates similar to the USB-to-Serial Converters.</p> Back of Bluetooth Mate and BlueSMiRF <p>Fast forward to January 2024 (my how time flies!), the BlueSMiRFs v2 is brought back to life! So what's different from the previous versions? Well, the differences to note with the BlueSMiRF v2 include:</p> <ul> <li>ESP32-PICO-MINI-02 module</li> <li>firmware can be easily updated Over-the-Air or through a command line interface</li> <li>the pinout matches the previous Bluetooth Mates and standard USB-to-serial converters: RTS/RXI/TXO/VCC/CTS/GND</li> <li>labels included on both sides of the board instead of just the bottom</li> <li>multi-use button for setting the board in bootloader mode, pairing, and factory reset instead of a PTH PIO4 for factory reset</li> <li>jumper to disable the button</li> <li>CTS/RTS jumper was removed</li> <li>APA2112K 3.3V, 600mA voltage regulator instead of the MIC5205 3.3V, 150mA</li> <li>a bypass jumper for the voltage regulator was added</li> <li>size is slightly smaller measuring 38.1mm x 15.2mm</li> </ul>"},{"location":"resources/","title":"Resources","text":"<p>Now that you've successfully got your SparkFun BlueSMiRF v2 up and running, it's time to incorporate it into your own project! For more information, check out the resources below:</p> <ul> <li>PTH<ul> <li>Schematic (PDF)</li> <li>KiCad Files (ZIP)</li> <li>3D Model (STEP)</li> <li>Board Dimensions (PNG)</li> </ul> </li> <li>SMD, with headers<ul> <li>Schematic (PDF)</li> <li>KiCad Files (ZIP)</li> <li>3D Model (STEP)</li> <li>Board Dimensions (PNG)</li> </ul> </li> <li>Datasheet (PDF) (ESP32-PICO-MINI-02)</li> <li>Firmware</li> <li>GitHub Hardware Repo</li> <li>SFE Product Showcase</li> </ul>"},{"location":"single_page/","title":"Introduction","text":"<p>The SparkFun BlueSMiRF v2 is a wireless Bluetooth\u00ae serial link. This version of the popular BlueSMiRF uses the ESP32. These boards work as a wireless serial UART pipe and are a great wireless replacement for serial cables. Simply pair, connect, and transmit serial data between your TX/RX lines! Any serial stream from 2400 to 921600 baud can be passed seamlessly between two devices.</p> <p> <ul> <li> <p> </p> <p> SparkFun BlueSMiRF v2    WRL-24113    Purchase from SparkFun  </p> </li> </ul> <ul> <li> <p> </p> <p> SparkFun BlueSMiRF v2 - Headers    WRL-23287    Purchase from SparkFun  </p> </li> </ul> <p></p> <p>In this tutorial, we'll go over the hardware and how to hookup the breakout board. We will also go over how to connect to a smartphone and a basic Arduino example to get started!</p>"},{"location":"single_page/#required-materials","title":"Required Materials","text":"<p>To follow along with this tutorial, you will need the following materials. You may not need everything though depending on what you have. Add it to your cart, read through the guide, and adjust the cart as necessary. We recommend the board with headers to minimize the amount of soldering to your application.</p> <ul> <li>2x SparkFun BlueSMiRF v2 - Headers [WRL-23287]</li> <li>2x Jumper Wires Premium 6\" M/F Pack of 10 [PRT-09140]</li> <li>2x SparkFun Serial Basic Breakout - CH340C and USB-C [DEV-15096]</li> <li>2x Reversible USB A to C Cable - 0.8m [CAB-15425]</li> </ul> <ul> <li> <p> </p> <p> SparkFun BlueSMiRF v2 - Headers    WRL-23287 </p> </li> </ul> <ul> <li> <p> </p> <p> Jumper Wires Premium 6\" M/F Pack of 10    PRT-09140 </p> </li> </ul> <ul> <li> <p> </p> <p> SparkFun Serial Basic Breakout - CH340C and USB-C    DEV-15096 </p> </li> </ul> <ul> <li> <p> </p> <p> Reversible USB A to C Cable - 0.8m    CAB-15425 </p> </li> </ul>"},{"location":"single_page/#tools-optional","title":"Tools \u00a0(Optional)","text":"<p>You will need a soldering iron, solder, and general soldering accessories for a secure connection when using the plated through holes. You may also need to solder headers or wires to any devices that the BlueSMiRF v2 is connecting to.</p> <ul> <li>Soldering Iron [TOL-14456]</li> <li>Solder Lead Free - 15-gram Tube [TOL-9163]</li> <li>Flush Cutters - Xcelite [TOL-14782]</li> <li>Hook-Up Wire - Assortment (Stranded, 22 AWG) [PRT-11375]</li> <li>Wire Strippers - 20-30 AWG [TOL-24771]</li> </ul> <ul> <li> <p> </p> <p> Soldering Iron - 60W (Adjustable Temperature)    TOL-14456 </p> </li> </ul> <ul> <li> <p> </p> <p> Solder Lead Free - 15-gram Tube    TOL-09163 </p> </li> </ul> <ul> <li> <p> </p> <p> Hook-Up Wire - Assortment (Stranded, 22 AWG)    PRT-11375 </p> </li> </ul> <ul> <li> <p> </p> <p> Wire Strippers - 20-30 AWG    TOL-24771 </p> </li> </ul> <ul> <li> <p> </p> <p> Flush Cutters - Xcelite    TOL-14782 </p> </li> </ul>"},{"location":"single_page/#prototyping-accessories-optional","title":"Prototyping Accessories \u00a0(Optional)","text":"<p>For those using the PTH version, you will need to connect to the PTHs. You could use IC hooks and a breadboard for a temporary connection depending on your setup and what you have available. Of course, you will want to the solder header pins for a secure connection. We'll assume that you will want to solder a female header since there is already a BlueSMiRF v2 with the male headers available. Then again, you can still solder wire or even your own male headers if you prefer. Below are a few prototyping accessories that you may want to consider.</p> <ul> <li>Breadboard - Self-Adhesive (White) [PRT-12002]</li> <li>IC Hook with Pigtail [CAB-09741]</li> <li>Header - 6-pin Female (PTH, 0.1\") [PRT-11894]</li> <li>Arduino Stackable Header - 6 Pin [PRT-09280]</li> <li>Break Away Headers - Straight [PRT-00116]</li> <li>Break Away Headers - 40-pin Male (Long Centered, PTH, 0.1\") [PRT-12693]</li> <li>Jumper Wires Premium 6\" M/F Pack of 10 [PRT-09140]</li> <li>Jumper Wires Premium 6\" F/F Pack of 10 [PRT-08430]</li> </ul> <ul> <li> <p> </p> <p> Breadboard - Self-Adhesive (White)    PRT-12002 </p> </li> </ul> <ul> <li> <p> </p> <p> IC Hook with Pigtail    CAB-09741 </p> </li> </ul> <ul> <li> <p> </p> <p> Female Headers    PRT-11894 </p> </li> </ul> <ul> <li> <p> </p> <p> Arduino Stackable Header - 6 Pin    PRT-09280 </p> </li> </ul> <ul> <li> <p> </p> <p> Break Away Headers - Straight    PRT-00116 </p> </li> </ul> <ul> <li> <p> </p> <p> Break Away Headers - 40-pin Male (Long Centered, PTH, 0.1\")    PRT-12693 </p> </li> </ul> <ul> <li> <p> </p> <p> Jumper Wires Premium 6\" M/F Pack of 10    PRT-09140 </p> </li> </ul> <ul> <li> <p> </p> <p> Jumper Wires Premium 6\" M/M Pack of 10    PRT-08431 </p> </li> </ul> <ul> <li> <p> </p> <p> Break Away Male Headers - Right Angle    PRT-00553 </p> </li> </ul>"},{"location":"single_page/#you-will-also-need","title":"You Will Also Need","text":"<p>Depending on your setup or what you are doing, you may need the following as well.</p> <ul> <li>2.4GHz WiFi Network for firmware updates</li> <li>Smartphone with an Internet Service</li> </ul>"},{"location":"single_page/#suggested-reading","title":"Suggested Reading","text":"<p>If you aren\u2019t familiar with the following concepts, we also recommend checking out a few of these tutorials before continuing.</p> <ul> <li> <p> </p> <p> Bluetooth Basics </p> </li> </ul> <ul> <li> <p> </p> <p> Serial Terminal Basics </p> </li> </ul> <ul> <li> <p> </p> <p> Serial Communication </p> </li> </ul> <ul> <li> <p> </p> <p> How to Solder: Through-Hole Soldering </p> </li> </ul> <ul> <li> <p> </p> <p> Logic Levels </p> </li> </ul>"},{"location":"single_page/#old-school-to-new-school","title":"Old School to New School","text":"<p>Before we go over the hardware though, let's compare previous SparkFun BlueSMiRF versions with the BlueSMiRF v2!</p> <p>Back in April 2005, we originally released the BlueSMiRF v1 (short for Bluetooth Serial Miniature RF Link version 1) with BlueRadio's WML-C40AH. They came in two flavors: one with 4-pins for the basic BlueSMiRF consisting of PWR/GND/TX-O/RX-I, and the other with 6-pins for the extended BlueSMiRF consisting of RTS/RX-I/TX-O/GND/PWR/CTS. Over the years, the extended 1x6 pin became the \"standard\" for the BlueSMiRF.</p> Basic BlueSMiRF Extended BlueSMiRF <p>We even saw changes in the Bluetooth modems! The BlueRadio's WML-C40AH modems eventually switched over to Roving Network's RN-41 and RN-42. Each version had different ranges and transmit power.</p> BlueSMiRF Gold (RN-42) BlueSMiRF Silver (RN-41) <p>The 1x6 pins also were rearranged for the SparkFun Bluetooth Mates similar to the USB-to-Serial Converters.</p> Back of Bluetooth Mate and BlueSMiRF <p>Fast forward to January 2024 (my how time flies!), the BlueSMiRFs v2 is brought back to life! So what's different from the previous versions? Well, the differences to note with the BlueSMiRF v2 include:</p> <ul> <li>ESP32-PICO-MINI-02 module</li> <li>firmware can be easily updated Over-the-Air or through a command line interface</li> <li>the pinout matches the previous Bluetooth Mates and standard USB-to-serial converters: RTS/RXI/TXO/VCC/CTS/GND</li> <li>labels included on both sides of the board instead of just the bottom</li> <li>multi-use button for setting the board in bootloader mode, pairing, and factory reset instead of a PTH PIO4 for factory reset</li> <li>jumper to disable the button</li> <li>CTS/RTS jumper was removed</li> <li>APA2112K 3.3V, 600mA voltage regulator instead of the MIC5205 3.3V, 150mA</li> <li>a bypass jumper for the voltage regulator was added</li> <li>size is slightly smaller measuring 38.1mm x 15.2mm</li> </ul>"},{"location":"single_page/#hardware-overview","title":"Hardware Overview","text":"<p>In this section, we will highlight the hardware and pins that are broken out on the SparkFun BlueSMiRF v2. For the scope of the tutorial, we will be referring to the version with the headers.</p> SMD with Headers, Top View SMD with Headers, Bottom View <p>There is also a version with PTHs out in the wild and it is essentially the same. The only differences are that the pins are broken out to PTHs instead of a SMD right angle male header and the silkscreen labels.</p> PTH Version, Top View PTH Version, Bottom View <p>For more information, check out our Resources and Going Further for the board designs and the ESP32.</p>"},{"location":"single_page/#esp32-pico-mini-02","title":"ESP32-PICO-MINI-02","text":"<p>The board includes the smaller ESP32-PICO-MINI-02 module from Espressif. The SparkFun BlueSMiRF v2 is perfect for short range applications that require point-to-point communication. We've written some firmware to allow serial UART data to be sent between two Bluetooth devices. The supported protocols include SPP and BLE. Testing a pair of BlueSMiRF v2s and we got about ~110 feet (~33m) in the SparkFun building. The TX (10k) and RX (50k) buffers are also very large to allow for radio delays. The included firmware also includes a set of AT commands to configure the ESP32. This includes the baud rate, flow control, LED mode, and Over-The-Air (OTA) updates over a 2.4GHz WiFi network to name a few. You can also manually reprogram the ESP32 module using the command line interface as well! Just make sure to connect Tx and Rx between the BlueSMiRF and a USB-to-serial converter.</p>"},{"location":"single_page/#power","title":"Power","text":"<p>Power is broken out on the 1x6 header through the VCC and GND pins. The recommended input voltage can be between 3.3V to 5V. Logic level shifting circuitry is included on the TX and RX pins so that they are 3.3V to 5V tolerant.</p> <ul> <li>VCC / 3V3-5V \u2014 On the top of the board, the input voltage is labeled as VCC. On the back of the board, this is labeled as 3V3-5V. Voltage is regulated down with the AP2112K 3.3V/600mA voltage regulator from this pin. Typically, one would apply either 3.3V or 5V to this pin. Make sure that power you provide to this pin does not exceed 6 volts. For advanced users, you can bypass this voltage regulator by adding a solder blob on the jumper labeled as JP2. Be careful as the input voltage range is smaller and you may run the risk of damaging the ESP32.</li> <li>GND \u2014 Of course, is the common, ground voltage (0V reference) for the system.</li> </ul> Power, Top View Power, Bottom View <p>The current and power consumption depends on what it's doing at the time. Here are some of our results after measuring the current and power consumption at 3.3V. The module can get toasty when pushing serial traffic through but not scary-burn-you-hot.</p> <ul> <li>Idle: 72mA / 238mW</li> <li>Connected with no Serial Traffic: 75mA / 248mW</li> <li>Constant Duplex Serial Traffic: 140mA / 462mW</li> </ul> <p>Note</p> <p>There are also test points on the back of the board that are not labeled for VCC and GND. These are not labeled and are used by SparkFun's production for testing &amp; programming the board using test beds.</p>"},{"location":"single_page/#reset","title":"Reset","text":"<p>The reset PTH labeled as RST will restart the ESP32 whenever the pin is grounded.</p> Reset, Top View Reset, Bottom View"},{"location":"single_page/#serial-uart-port","title":"Serial UART Port","text":"<p>Note</p> <p>As stated in the previous section, the pinout of the BlueSMiRF v2 is different from previous BlueSMiRFs, hence the version 2. Besides the ESP32 module, the pinout has the same pinout as previous Bluetooth Mates and USB-to-serial converters (i.e. FTDI, CH340, etc.). The board is meant to connect directly with an Arduino Pro, Pro Mini, RTCM Correction Ports on high precision GNSS breakout boards, or any board with a standard serial-to-USB port. Below is the back of the Bluetooth Mate, BlueSMiRF, and BlueSMiRF v2 boards.</p> <p> Back of Bluetooth Mate, BlueSMiRF, and BlueSMiRF v2 </p> <p>Both boards include a standard serial UART header seen on many USB-to-serial converters: RTS/RXI/TXO/VCC/CTS/GND. Depending on the version that you purchase, one will be PTH while the other includes right angle male headers. Due to spacing, the PTH version will also have slightly different silkscreen labels.</p> <ul> <li>RTS / RT \u2014 The Ready to Send is an output and is used for hardware flow control in some serial interfaces. This output is not critical for simple serial communication. If flow control is enabled, BlueSMiRF will drive its RTS low if its serial buffer is full (the radio is telling the host system to hold its horses). <li>RXI / RI \u2014 The serial receive is an input. This input pin receives serial data from another serial device. Logic level circuitry is included on this pin. It should be connected to the TX of the other device.</li> <li>TXO / TO \u2014  The serial transmit is an output. This output pin sends serial data to another device. Logic level circuitry is included on this pin. It should be connected to the RX of the other device.</li> <li>VCC/ V / 3V3-5V \u2014 This input voltage supply signal is routed through a AP2112K voltage regulator and brought down 3.3V for the ESP32. We will assume that it is attached to another device's standard serial port and it is providing power to the BlueSMiRF v2. As stated earlier, the recommended input voltage is between 3.3V to 5V.</li> <li>CTS / CT \u2014 The Clear to Send is an input. CTS is another serial flow control signal. Like RTS, it's not required for most, simple serial interfaces. If flow control is enabled, BlueSMiRF will send data when its CTS pin is driven low (the host system is telling the radio that it's ready for more serial data).</li> <li>GND / G \u2014 The 0V reference voltage, common to any other device connected to the Bluetooth modem.</li> Serial Header, Top View Serial Header, Bottom View PTH Serial Header, Top View PTH Serial Header, Bottom View <p>Tip</p> <p>For those that are connecting to the old school RS232 serial port, you will need a RS232 to TTL converter for higher voltages. The RS232 to TTL converter can handle larger voltages designed for RS232.</p> <p> SparkFun RS232 Shifter - SMD       PRT-00449 </p>"},{"location":"single_page/#button","title":"Button","text":"<p>The PAIR button is more than meets the eye. This button has more than one function depending on how long it is pushed down.</p> <ul> <li>Short Push \u2014 Press and hold the button down between 4 to 8 seconds will initiate pairing with another Bluetooth device. During that period of time, the Status and Connect LEDs will slowly blink back and forth. When the BlueSMiRF v2 fails to discover any compatible devices, it will enter Discoverable mode.</li> <li>Long Push \u2014 Press and hold the down for more than 8 seconds to set the ESP32 back to its factory default settings.</li> </ul> <p>Note</p> <p>Users can also set the BlueSMiRF v2 in bootloader mode. In this mode, you can update the firmware manually through serial using a command line interface. Users will need to hold down the PAIR button when the BlueSMiRF v2 is not powered. Applying power will put the microcontroller into bootloader mode.</p> <p>For more information about using the button for each mode, check out the section about the button control.</p> Button Control"},{"location":"single_page/#leds","title":"LEDs","text":"<p>The board includes the following status LEDs as indicated in the image below.</p> <ul> <li>CONNECT \u2014 The connect LED indicates when the ESP32 is connected to another Bluetooth device. The behavior of the LED will depend on the mode:<ul> <li><code>0</code> \u2014 By default, the CONNECT LED will blink until it is connect to another Bluetooth device. Once connected, this LED will remain solid.</li> <li><code>1</code> \u2014 When set to a <code>1</code>, the CONNECT LED will blink until it is connected to another Bluetooth device. Once connected, this LED will blink with TX traffic.</li> </ul> </li> <li>STATUS \u2014 The status LED indicates when there is UART traffic. The behavior of the LED will depend on the mode.<ul> <li><code>0</code> \u2014 By default, the STATUS LED blinks with any TX/RX traffic.</li> <li><code>1</code> \u2014 When set to a <code>1</code>, the STATUS LED blinks with only the RX traffic.</li> </ul> </li> </ul> <p>The LEDs can also blink at different rates, fade, or become dim when the PAIR button is held down. This is used as an indicator to tell when we are entering pairing, factory reset, or bootloader mode. For more information, check out the section about the button control.</p> Button Control"},{"location":"single_page/#jumpers","title":"Jumpers","text":"<p>Note</p> <p>If this is your first time working with jumpers, check out the How to Work with Jumper Pads and PCB Traces tutorial for more information.</p> <p>The board includes the following jumpers on the top and bottom of the board.</p> <ul> <li>JP2 \u2014 Jumper pad 2 is open by default. This jumper is used to bypass the 3.3V voltage regulator. Add a solder blob to close the jumper to connect VCC to 3.3V.</li> <li>BTN \u2014 The button jumper are closed by default. This connects the pair button to GPIO pin 0. Cut this jumper to disable the button.</li> </ul> Jumpers, Top View Jumpers, Bottom View"},{"location":"single_page/#3d-model","title":"3D Model","text":"<p>A 3D model of the SparkFun BlueSMiRF v2 SMD and components was exported to STEP file using KiCad.</p> <p></p> Click Here for the STEP File <p>A 3D model of the SparkFun BlueSMiRF v2 PTH and components was also exported to STEP file using KiCad.</p> <p></p> Click Here for the STEP File"},{"location":"single_page/#board-dimensions","title":"Board Dimensions","text":"<p>Each version of the board is 38.1mm x 15.2mm. Note that the version with the headers makes the board slightly longer by making the overall length 44.2mm. Adding a row of female 1x6 headers or jumper wires will increase the length slightly as well. There are no mounting holes for standoffs on the boards.</p> Board Dimensions for PTH, without Headers Board Dimensions for SMD with Headers"},{"location":"single_page/#hardware-hookup","title":"Hardware Hookup","text":"<p>In this section, we'll go over how to connect to the BlueSMiRF v2.</p>"},{"location":"single_page/#connecting-via-bluesmirf-v2-pth","title":"Connecting via BlueSMiRF v2 PTH","text":"<p>For a temporary connection to the PTH BlueSMiRF v2, you could use IC hooks to test out the pins. However, you'll need to solder headers or wires of your choice to the board for a secure connection. You can choose between a combination of header pins and jumper wires, or stripping wire and soldering the wire directly to the board.</p> <ul> <li> <p> </p> <p> How to Solder: Through Hole Soldering </p> </li> </ul> <ul> <li> <p> </p> <p> Working with Wire </p> </li> </ul>"},{"location":"single_page/#basic-serial-uart-connection","title":"Basic Serial UART Connection","text":"<p>At a minimum, you will need to connect serial TX, serial RX, power, and ground for a basic serial UART connection. This connection is needed to send serial data between the two UART devices, configure settings, or even manually upload binaries to the ESP32. Between each serial device, always make sure to cross the RX and TX lines between serial devices (i.e. RX-to-TX and TX-to-RX). The table indicates below shows color cells being the same for the TXO-to-RXI and RXI-to-TXO. Note that the order of the pins may be different depending on the design, so you may not be able to make a direct connection with the BlueSMiRF v2's 1x6 header.</p> Serial DevicePinout              BlueSMiRF v2Pinout              TXO RXI RXI TXO 3V3 VCC GND GND <p>Note</p> <p>In some cases, you may only need to just wire one serial wire from your serial device to the BlueSMiRF.</p>"},{"location":"single_page/#usb-to-serial-converter-to-bluesmirf-v2","title":"USB-to-Serial Converter to BlueSMiRF v2","text":"<p>Depending on the USB-to-serial converter that you choose, you may need to install drivers. If you've never connected an FTDI or CH340 to your computer before, you may need to install drivers for the USB-to-serial converter. Check out our How to Install FTDI Drivers or How to Install CH340 Drivers tutorial for help with the installation.</p> <ul> <li> <p> </p> <p> How to Install FTDI Drivers </p> </li> </ul> <ul> <li> <p> </p> <p> How to Install CH340 Drivers </p> </li> </ul> <p>To make a connection to a USB-to-serial converter, you will need a basic serial connection. There are several converters available such as the FT232 or CH340. Each of these boards include a different USB connector. You will need to manually wire them up using jumper wires as shown in the table and image below.</p> USB-to-Serial ConverterPinout              Intermediate Wire Connection BlueSMiRF v2Pinout              DTR RTS RXI RXI TXO TXO 3V3 VCC CTS CTS GND GND <p>Note</p> <p>The connection also includes two additional connection for flow control: RTS and CTS. These two connections are not needed for a basic serial UART connection. However, using all six wires can help make a tighter connection on the 1x6 header. The wire colors also connect TXO-to-RXI and RXI-to-TXO to indicate that it is not a direct connection between the two boards and the 1x6 header.</p> <p>Below is one example between the serial basic breakout (CH340, USB-C) and the BlueSMiRF v2 Header. Male to female jumper wires were connected between the boards.</p> USB-to-Serial Converter (CH340) to BlueSMiRF v2 Header with TX-to-RX and RX-to-TX <p>Adding a simple 1x6 stackable header between the jumper wires will make a quick adapter with the M/F jumper wires and USB-to-serial converter. You'll just need to match the DTR and GND pins. This is useful for those that need to constantly configure the BlueSMiRF v2's settings and re-reconnect to a USB-to-serial converter.</p> USB-to-Serial Converter (CH340) to BlueSMiRF v2 Header with an Additional Stackable Header <p>Tip</p> <p>To make it easier to connect visually, try adding a polarity marker with whiteout, Sharpie, or paint. You can even try rotating one of the jumper wires so that the metal tabs is not facing the same direction on one or both ends.</p> <p>Remember, for those that are using the PTH version, you will need to solder either male headers, female headers, or wires. The type of header or wire will depend on your personal preference and project needs. In this case, we used a 1x6 female header to the board. At the time of writing, there were only female to male jumper wires available so extra long headers were placed between the female header pins. The male header was connected to another serial basic (CH340).</p> USB-to-Serial Converter (CH340) to BlueSMiRF v2 PTH"},{"location":"single_page/#bluesmirf-v2-to-standard-serial-uart-port","title":"BlueSMiRF v2 to Standard Serial UART Port","text":"<p>For boards that already include the footprint for a standard serial UART port, you can connect directly to the pins. You will find these on a few Arduino development boards. The Arduino Pro, Arduino Pro Mini, and LilyPad Arduino 328 Main Board are just a few boards that have the standard port. You will also notice certain boards will have the standard serial UART port labeled as the RTCM Correction Port on SparkFun high precision GNSS breakout boards. For certain boards that have a male header soldered, you may need to consider soldering a 1x6 female header on the BlueSMiRF v2 PTH.</p> BlueSMiRF v2 Replacing Serial Connection on the Arduino Pro Mini 3.3V Serial Header Port BlueSMiRF v2 Connected to the ZED-F9P's RTCM Correction Port UM980 with the BlueSMiRF v2 Connected to the UM980's RTCM Correction Port <p>Note</p> <p>There are older boards that may have a serial port labeled as BlueSMiRF. You will need to wire the connection manually with jumper wires. One example is the SparkFun Arduino ProtoShield where the board uses the older BlueSMiRF pinout. There are jumpers that you can cut on the board and additional PTHs to rewire the pins if you decide to connect directly to the 1x6 header.</p> <p> SparkFun Arduino ProtoShield Serial Port Highlighted </p>"},{"location":"single_page/#at-command-reference","title":"AT Command Reference","text":"<p>Each BlueSMiRF v2 firmware comes with a set of AT commands to read or change the configuration. The following set of AT commands are similar to previous BlueSMiRF AT commands. Let's go over some of these commands!</p>"},{"location":"single_page/#at-commands","title":"AT Commands","text":"<p>Note</p> <p>Command mode cannot be entered 60 seconds after power-on or resetting. This setting can be configured with the command <code>AT-MaxCommandTimeMs</code>.</p> <p>BlueSMiRF radios are very flexible. By default, the radio is looking for serial communication at 115200 bps. Open the terminal of your choice. Then enter <code>$$$</code> and wait for an <code>OK</code>. Both the CONNECT and STATUS LEDs will fade in and fade out whenever the board is in Command Mode. At this point, the radio is now ready for an AT command.</p> BlueSMiRF v2 Connected to Serial Terminal and in Command Mode <p>Note</p> <p>Depending on your serial terminal's settings, you may not see the characters that are being sent. You can try turning on the local echo to view the characters. However, keep in mind that any characters sent when the BlueSMiRF v2 is in command mode will already be echoed back.</p> <p>Note</p> <p>The device can also be configured by connecting over Bluetooth and entering <code>$$$</code>.</p> <p>Below is a brief list of commands. The BlueSMiRF will recognize commands with capital and lower case letters since the commands are not case sensitive.</p> AT Command              Command Description              <code>$$$</code>                Enter Command Mode              <code>AT</code>                Reports OK              <code>AT?</code>                Display this help text              <code>ATA</code>                Display all settings              <code>ATB</code>                Display Bluetooth settings              <code>ATC</code>                Check for new firmware              <code>ATD</code>                Display the debug settings              <code>ATF</code>                Restore factory settings              <code>ATM</code>                Display MAC address              <code>ATP</code>                Start pairing process              <code>ATS</code>                Display serial settings              <code>ATU</code>                Update Firmware              <code>ATV</code>                Display firmware version              <code>ATW</code>                Save current settings to NVM              <code>ATX</code>                Exit command mode              <code>ATY</code>                Display system settings              <code>ATZ</code>                Reboot the system              <code>AT-Param=xxx</code>                Set parameter's value to xxx by name (Param)              <code>AT-Param?</code>                Print parameter's current value by name (Param)              <code>AT-?</code>                Display the setting values              AT Commands <p>A parameter is set using the AT- prefix, followed by the name of the command with an equals sign and the value to set. For example, sending AT-SerialSpeed=115200 followed by the ENTER key (or a carriage return) will change the serial interface speed to 115200bps. This setting can be stored in NVM (non-volatile memory) by sending the ATW command.</p> <p>To query a setting, send the AT command without a value and the device will respond with the current value. For example, sending AT-SerialSpeed followed by the ENTER key will generate the response 115200 followed by OK.</p> <p>The commands are best discussed in groups:</p> <ul> <li>Bluetooth Commands</li> <li>Serial Commands</li> <li>System Commands</li> </ul>"},{"location":"single_page/#bluetooth-commands","title":"Bluetooth Commands","text":"<p>Below is a table for Bluetooth commands, a short description of the command, and its factory default value (if applicable). Right after the table, there is also a list which provides a detailed explanation of each parameter as well.</p> AT Command              Command Description              Factory Default Value              <code>AT-BluetoothConnectRetries</code>                Number of retries of a paired connection                             5              <code>AT-BluetoothConnectTimeoutMs</code>                Milliseconds before a paired connection attempt times out                             3000              <code>AT-BluetoothEscapeCharacter</code>                The character received from the remote system, sought to enter command mode              +              <code>AT-BluetoothNickname</code>                User configurable name to broadcast over Bluetooth during discovery                             \"BlueSMiRF-ABCD\", where ABCD is the last four hex digits of the Bluetooth MAC              <code>AT-BluetoothPairedMac</code>                MAC address of the unit that the user wants to connect to at startup              <code>AT-BluetoothPairedName</code>                Name of the unit that the user wants to connect to at startup              <code>AT-BluetoothPin</code>                Pin to enter during pairing - only required for older Bluetooth devices              1234              <code>AT-BluetoothRxSize</code>                Bluetooth receive buffer size                             2048              <code>AT-BluetoothTxSize</code>                Bluetooth write buffer size                             1024              <code>AT-BluetoothType</code>                Bluetooth protocol used for communication                             0              Bluetooth Commands <ul> <li> <p>BluetoothConnectRetries \u2014 If this device has a paired MAC or name, at power up it will attempt to connect to this paired device. A connection is not guaranteed, and the connection will be re-tried this number of times before going into passive, discoverable mode.</p> </li> <li> <p>BluetoothConnectTimeoutMs \u2014 When this device is connecting to a paired device, if this number of milliseconds expires before a connection is made, the device will attempt to reconnect to the paired device.</p> </li> <li> <p>BluetoothEscapeCharacter \u2014 This is the character that must be transmitted by a remote device to enter command mode remotely over the Bluetooth connection.</p> <p>Note</p> <p>Escape characters are ignored after <code>MaxCommandTimeMs</code> number of milliseconds and within <code>MinEscapeTimeMs</code> of other incoming characters.</p> </li> <li> <p>BluetoothNickname \u2014 The name that is broadcast when other devices are scanning for devices to pair to.</p> </li> <li> <p>BluetoothPairedMac \u2014 The MAC address of the BlueSMiRF that this device should pair to at power-on. Use the <code>ATM</code> command on the remote device to display its MAC address. This command is not normally used; use the button pairing method for an easier way to pair two devices.</p> </li> <li> <p>BluetoothPairedName \u2014 The name of the BlueSMiRF that this device should pair to at power-on. Use the <code>BluetoothNickname</code> command on the remote device to change its paired name. This command is not normally used; use the button pairing method for an easier way to pair two devices.</p> </li> <li> <p>BluetoothPin \u2014 The pin that is needed during pairing. Only needed on very old Bluetooth USB dongles.</p> </li> <li> <p>BluetoothRxSize \u2014 The size of the Bluetooth receive buffer. Increase if a large amount of data is coming into the BlueSMiRF over Bluetooth, before the speed of the serial interface can output it.</p> </li> <li> <p>BluetoothTxSize \u2014 The size of the Bluetooth transmit buffer. Increase if a large amount of data needs to be transmitted over Bluetooth but the connection between devices is poor and multiple retransmissions occur.</p> </li> <li> <p>BluetoothType \u2014 Controls the Bluetooth protocol. This parameter accepts a <code>0</code>, <code>1</code>, and <code>2</code> for the Bluetooth Protocol as listed below. Note that only the SPP protocol supports pairing.</p> <ul> <li>Protocol <code>0</code> = Serial Port Profile (SPP)</li> <li>Protocol <code>1</code> = Bluetooth Low-Energy (BLE)</li> <li>Protocol <code>2</code> = Radio off</li> </ul> </li> </ul>"},{"location":"single_page/#serial-commands","title":"Serial Commands","text":"<p>Below is a table for serial commands, a short description of the command, and its factory default value (if applicable). Right after the table, there is also a list which provides a detailed explanation of each parameter as well.</p> AT Command              Command Description              Factory Default Value              <code>AT-FlowControl</code>                Enable the use of CTS/RTS flow control signals                             0              <code>AT-InvertCts</code>                Invert the input of CTS                             0              <code>AT-InvertRts</code>                Invert the output of RTS                             0              <code>AT-PartialFrameTimeoutMs</code>                Send partial buffer if time expires                             50              <code>AT-RtsStartSendingPercent</code>                Percent of serialReceiveBuffer that is free when RTS is asserted                             25              <code>AT-RtsStopSendingPercent</code>                Percent of serialReceiveBuffer that is free when RTS is deasserted                             5              <code>AT-SerialReceiveBufferSize</code>                Serial receive buffer size                             51200              <code>AT-SerialSpeed</code>                The baud rate that the BlueSmiRF operates at.                             115200              <code>AT-SerialTransmitBufferSize</code>                Buffer size to receive bytes from Bluetooth                             10240              Serial Commands <ul> <li> <p>FlowControl - If flow control is enabled, the BlueSMiRF v2 will send data when its CTS pin is driven low (the host system is telling the radio to transmit). If flow control is enabled, BlueSMiRF v2 will drive its RTS low if its serial buffer is full (the radio is telling the host system to hold its horses). By default, flow control is turned off.</p> </li> <li> <p>InvertCts - By default, InvertCts is false and CTS is high when data is allowed to flow. Enable InvertCts to do the opposite.</p> </li> <li> <p>InvertRts - By default, InvertRts is false and RTS is high when data is allowed to flow. Enable InvertRts to do the opposite.</p> </li> <li> <p>PartialFrameTimeoutMs - The number of milliseconds of timeout before a partial packet is sent. For example, if a partial frame of 12 bytes is received, the radio will wait this amount for more bytes before initiating a transmission.</p> </li> <li> <p>RtsStartSendingPercent - Percent of serialReceiveBuffer that is free when RTS is asserted. Default of 25% of serialReceiveBuffer.</p> </li> <li> <p>RtsStopSendingPercent - Percent of serialReceiveBuffer that is free when RTS is deasserted. Default of 5% of serialReceiveBuffer.</p> </li> <li> <p>SerialReceiveBufferSize - Buffer size to receive serial data from the serial port, to be sent over Bluetooth. The default is 51200.</p> </li> <li> <p>SerialSpeed - The baud rate that the BlueSMiRF operates at. Discrete values 2400, 4800, 9600, 14400, 19200, 38400, 57600, 115200 (default), 230400, 460800, and 921600bps are allowed.   </p> </li> <li> <p>SerialTransmitBufferSize - Buffer size to receive bytes from Bluetooth, waiting to be printed out the UART. The default is 10240.</p> </li> </ul>"},{"location":"single_page/#system-commands","title":"System Commands","text":"<p>Below is a table for system commands, a short description of the command, and its factory default value (if applicable). Right after the table, there is also a list which provides a detailed explanation of each parameter as well.</p> AT Command              Command Description              Factory Default Value              <code>AT-EscapeCharacter</code>                The character sought to enter command mode                             $              <code>AT-EscapeCharacterCount</code>                The number of escape characters required to enter command mode                             3              <code>AT-LedStyle</code>                Controls the behavior of the Status and Connect LEDs                             0              <code>AT-MaxCommandTimeMs</code>                After this time in milliseconds, command mode cannot be entered                             60000              <code>AT-MinEscapeTimeMs</code>                Serial traffic must stop this amount of milliseconds before an escape character is recognized                              2000              <code>AT-WiFiPassword</code>                Password for the SSID, used for over-the-air-updates              <code>AT-WiFiSSID</code>                SSID used for over-the-air-updates              System Commands <ul> <li> <p>EscapeCharacter \u2014 The character that must be entered a number of times (<code>EscapeCharacterCount</code>) to enter configuration mode. An escape character must be entered before the max time of <code>MaxCommandTimeMs</code> and after <code>MinEscapeTimeMs</code>.</p> </li> <li> <p>EscapeCharacterCount \u2014 The number of escape characters needed before command mode is entered. Set to 0 to disable.</p> </li> <li> <p>LedStyle - Controls how the LEDs behave: CLASSIC = <code>0</code>, SERIAL_TRAFFIC = <code>1</code>, OFF = <code>2</code>.</p> <ul> <li> <p>CLASSIC mode (default) = <code>0</code> \u2014 The STATUS LED blinks with TX/RX traffic.</p> </li> <li> <p>SERIAL_TRAFFIC mode = <code>1</code> \u2014 The CONNECT LED blinks with TX traffic and the STATUS LED blinks with RX traffic.</p> </li> <li> <p>OFF mode = <code>2</code> \u2014 The CONNECT and STATUS LEDs are turned off.</p> </li> </ul> </li> <li> <p>MaxCommandTimeMs \u2014 Once this number of milliseconds has passed, command mode cannot be entered. This is used as a method to prevent a remote system from accidentally entering command mode.</p> </li> <li> <p>MinEscapeTimeMs \u2014 This number of milliseconds must pass between the last serial character received and an escape character. This is used as a method to prevent a remote system from accidentally entering command mode.</p> </li> <li> <p>WiFiPassword \u2014 The password for the local WiFi used for firmware updates.</p> </li> <li> <p>WiFiSSID \u2014 The SSID for the local WiFi used for firmware updates.</p> </li> </ul>"},{"location":"single_page/#button-control","title":"Button Control","text":""},{"location":"single_page/#button-control_1","title":"Button Control","text":"<p>The PAIR button on the BlueSMiRF v2 allows the device to enter a few different states.</p> <ul> <li>Pairing Mode</li> <li>Factory Reset Mode</li> <li>Bootloader Mode</li> </ul>"},{"location":"single_page/#pairing-mode","title":"Pairing Mode","text":"<p>Pairing mode is used to connect two BlueSMiRF v2 devices for direct communication. This mode is not needed for general discovery; a phone or a laptop can simply discover the BlueSMiRF v2 in its default state.</p> <p>Holding the Pair button between 4 to 8 seconds will cause the Status and Connect LEDs to slowly blink back and forth. If the Pair button is released at this time, the device will enter Pairing mode.</p> GIF Setting BlueSMiRF v2 in Pairing Mode  <p>Generally speaking, to create a serial bridge between two BlueSMiRFs, one device needs to be in discoverable mode and the other device needs to discover it. This means, one device needs to have its Pair button held for 4 to 8 seconds then released. It will then fail to discover any compatible devices then enter Discoverable mode. Once this is done, the second device needs to have its Pair button held for 4 to 8 seconds, then released. The second device will then scan and discover the first device and pair with it. From this point on, the second device will always try to connect to the first device at power on.</p> <p>Once a BlueSMiRF has entered Pairing Mode, it will scan for other compatible BlueSMiRF devices. If no other compatible device is found after a few seconds, the BlueSMiRF will enter Discoverable mode. The device will broadcast the name 'BlueSMiRF-Pairing' and wait for an incoming connection.</p> <p>If a second device enters Pairing Mode, it will scan for other compatible BlueSMiRF devices broadcasting the name (you guessed it) 'BlueSMiRF-Pairing'. If a device is detected, the second device will connect to the first device, store the MAC address of the first device, and attempt to connect to it at every future power on. The first device will not be aware of or connect to the first device at power on.</p>"},{"location":"single_page/#factory-reset-mode","title":"Factory Reset Mode","text":"<p>Holding the Pair button for more than 8 seconds will cause the Status and Connect LEDs to quickly blink back and forth. If the Pair button is released at this time, the device will enter Factory Reset mode.</p> GIF Factory Reset <p>After a Factory Reset, all settings are reset to default and/or erased in the following way:</p> <ul> <li>The baud rate is set to 115200 bps.</li> <li>The escape character is set to '<code>$</code>' and a count of 3.</li> <li>The WiFi SSID and password are erased.</li> <li>Flow control is disabled.</li> <li>All the other system settings are returned to default.</li> </ul>"},{"location":"single_page/#bootloader-mode","title":"Bootloader Mode","text":"<p>Hold down the PAIR button when the BlueSMiRF v2 is not powered. Applying power will set the microcontroller to bootloader mode. The STATUS LED will be dim indicating that we are in Bootloader Mode. After uploading the firmware binaries to the ESP32, you will need to cycle power to the device as this does not automatically exit the bootloader mode.</p> GIF Setting the BlueSMiRF in Bootloader Mode <p>Note</p> <p>As stated in the hardware hookup when connecting a USB-to-serial converter, you will need to manually wire the TX-to-RX and RX-to-TX to a USB-to-serial converter with jumper wires.</p>"},{"location":"single_page/#example-1-bluesmirf-to-bluesmirf","title":"Example 1 - BlueSMiRF to BlueSMiRF","text":"<p>In this example, we will connect two BlueSMiRF v2 boards to two separate serial ports. We will then send characters from one serial terminal to a second serial terminal.</p> <p>The image below on the left shows the Serial Basic (CH340, USB-C) connected to the BlueSMiRF v2 Header using M/F jumper wires. Headers were used to easily remove and reconnect the BlueSMiRF v2 with headers. The image to the right shows the Serial Basic (CH340, micro-B) connected to the BlueSMiRF v2 PTH using M/F jumper wires. A row of female headers were soldered on the board. Extra long headers were placed between the female headers to easily remove and reconnect the BlueSMiRF v2 PTH as well.</p> USB-to-Serial Converter (CH340) to BlueSMiRF v2 Header with an Additional Stackable Header USB-to-Serial Converter (CH340) to BlueSMiRF v2 PTH <p>Note</p> <p>To distinguish between the two BlueSMiRFs, try labeling the two board. In this case, we chose had the one with male headers and the other one with female headers.</p> <p>Connect the first BlueSMiRF v2 to your computer's COM port. In this case, it was COM13. Press and hold the PAIR button between 4 to 8 seconds. The Status and Connect LEDs will slowly blink back and forth. The Connect LED will begin to fade in and out after a few seconds. Open a serial terminal and connect to the first BlueSMiRF at 115200 baud.</p> First Serial Terminal <p>At this point, connect the second BlueSMiRF v2 to your computer's COM port. In this case, it was COM18. Press and hold the second BlueSMiRF's PAIR button between 4 to 8 seconds. The second BlueSMiRF will scan the area for another BlueSMiRF and connect. Once connected, the Connect LEDs on both boards will remain solid. Open a second serial terminal, and connect to the second BlueSMiRF at 115200 baud. Move both serial terminals side by side.</p> Second Serial Terminal <p>Start typing characters in the first serial terminal. You should see them in the second serial terminal!</p> Sending Characters through First Terminal Receiving Characters through Second Terminal <p>Type a message in the second terminal window. You should see them in the first serial terminal!</p> Receiving Characters through First Serial Terminal Sending Characters through Second Terminal"},{"location":"single_page/#example-2-bluesmirf-to-smartphone","title":"Example 2 - BlueSMiRF to Smartphone","text":"<p>Note</p> <p>Bluetooth classic (Serial Port Profile or SPP) is primarily supported. This Bluetooth protocol is supported on Android phones, most desktops, and laptops. The BlueSMiRF v2 also supports the BLE protocol, available on all Apple phones.</p> <p>In this example, we will connect a BlueSMiRF v2 to a smartphone and send serial data using the Bluetooth classic protocol (also known as Serial Port Profile or SPP).</p> <p>The image below shows the Serial Basic (CH340, USB-C) connected to the BlueSMiRF v2 Header using M/F jumper wires. Headers were used to easily remove and reconnect the BlueSMiRF v2 with headers.</p> BlueSMiRF v2 to SmartPhone Bluetooth Classic Serial Terminal"},{"location":"single_page/#download-the-serial-bluetooth-terminal-app","title":"Download the Serial Bluetooth Terminal App","text":"<p>Head to your smartphone's app store. In this case, we were on an Android smartphone and used Google Play Store to download the Serial Bluetooth Terminal app. This app is great for development, debugging, and general use when using the BlueSMiRF's SPP and BLE protocols.</p> Google Play: Serial Bluetooth Terminal <p>Note</p> <p>If you have a different phone OS, there are many apps like the Serial Bluetooth Terminal available for different smartphones. Just do a search in your app store.</p>"},{"location":"single_page/#pair-the-bluesmirf-v2-with-your-smartphone","title":"Pair the BlueSMiRF v2 with your Smartphone","text":"<p>Once downloaded, turn on your Bluetooth and open your Bluetooth settings. Scroll down until you see the available devices. With BlueSMiRF powered up and in range, you should be able to see the device in discoverable mode listed as BlueSMiRF-ABCD, where ABCD is the last four hex digits of the Bluetooth MAC. In this case, it was BlueSMiRF-5A66.</p> BlueSMiRF Discovered on Android Smartphone <p>Click on the device to begin pairing. A message will pop up asking if you want to pair with the device. At this point, select \"Pair.\"</p> BlueSMiRF Discovered on Android Smartphone <p>Scroll up to your Paired devices and look for the BlueSMiRF to verify that it has paired with your phone.</p> BlueSMiRF-5A66 Showing Up as a Paired Bluetooth Device"},{"location":"single_page/#sending-characters-between-a-bluesmirf-and-smartphone","title":"Sending Characters Between a BlueSMiRF and Smartphone","text":"<p>Open the Serial Bluetooth Terminal app.</p> Serial Bluetooth Terminal Opened <p>Click on the connect icon to the left of the trash can icon. If all is well, you will get a message indicating that the BlueSMiRF is connected.</p> Connected to BlueSMiRF-5A66 <p>Open a serial terminal, and connect to the BlueSMiRF at 115200 baud. In this case, it was connected to COM13. Start typing characters in the serial terminal. You should see them in the Serial Bluetooth Terminal app!</p> Serial Terminal Connected to BlueSMiRF v2 Receiving Characters through the Serial Bluetooth Terminal  <p>Type a message and send them using the Serial Bluetooth Terminal app. You should see the message in the serial terminal!</p> Receiving Characters through First Serial Terminal Sending Characters through Serial Bluetooth Terminal <p>Sending serial data between the BlueSMiRF and smartphone using the Serial Bluetooth Terminal app is only the start! For example, you can use BlueSMiRF v2 and a smartphone to send/receive correction data to/from a high precision GNSS module. Try looking at the following methods to send data between the BlueSMiRF v2 and a smartphone. Just make sure to adjust the baud rate of the BlueSMiRF to match the high precision GNSS module's baud rate (for the u-blox modules, the correction port's default is typically set to 38400 baud). These are only a few ways to connect a high precision GNSS module to your smartphone's GNSS app to achieve an RTK Fixed Mode.</p> <ul> <li>Connecting the ZED-F9P to a Correction Source using an NTRIP Client</li> <li>Setting the ZED-F9P as a Correction Source</li> </ul>"},{"location":"single_page/#example-3-wireless-serial-lcd","title":"Example 3 - Wireless Serial LCD","text":"<p>In this example, we will be using the basic serial UART example from the SerLCD tutorial. However, the wires between the SparkFun RedBoard will be replaced with a pair of BlueSMiRF v2s.</p> AVR-Based Serial Enabled LCDs Hookup Guide | Serial UART: Example Code - Basic"},{"location":"single_page/#changing-the-baud-rate","title":"Changing the Baud Rate","text":"<p>Before using the BlueSMiRFs with the SerLCD, we need to make sure that the baud rates match. You can either change the baud rate on both BlueSMiRFs or the baud rate of the SerLCD. To keep the original Arduino code the same, let's change the baud rate on both of the BlueSMiRFs. This will also be a good exercise to change the baud rate using the AT Commands.</p> <p>Connect a USB-to-Serial converter to the BlueSMiRF. Depending on the BlueSMiRF that you have, you may need to solder headers. Then connect the USB cable between the converter and your computer.</p> USB-to-Serial Converter (CH340) to BlueSMiRF v2 Header with an Additional Stackable Header <p>Open a serial terminal and connect to the COM port at 115200 baud. Type $$$ within 60 seconds of powering the BlueSMiRF to enter command mode.</p> BlueSMiRF v2 Connected to Serial Terminal and in Command Mode <p>Type AT-SerialSpeed=9600 to change the baud rate to match the SerLCD's baud rate (which is set to 9600 baud by default). Enter ATW to save the settings.</p> Configuring the Baud Rate of the BlueSMiRF v2 <p>Now that the first BlueSMiRF v2 is configured, repeat the same steps explained above to change the baud rate of the second BlueSMiRF v2.</p>"},{"location":"single_page/#hardware-hookup_1","title":"Hardware Hookup","text":"<p>Replacing the connection with the BlueSMiRFs is similar to the basic serial UART connection listed earlier in this tutorial. We'll be using it as a guide to wire everything up. Since the SerLCD is only receiving data to display, we only need to use its RX pin.</p> <p>From the microcontroller, you will need to wire the following pins. Since the BlueSMiRF v2 includes logic level circuitry on the TX and RX pins, we can wire the SparkFun RedBoard Plus directly to the pin when the switch for the microcontroller's logic level is set to 5V. Notice that we are only wiring software serial TX pin since we are just sending characters from the microcontroller to the SerLCD. Users that want to also connect software serial RX pin can also wire the connection to the BlueSMiRF v2's TXO but it is not necessary. We will assume that we are using power supplied from a USB port or USB power supply.</p> SparkFun RedBoard Plus(ATmega328P) Pinout              Transmitting BlueSMiRF v2Pinout              7 RXI 5V VCC GND GND <p>On the SerLCD side, we can simply insert the BlueSMiRF v2 in the SerLCD's USB-to-serial 1x6 header. For users that are using the BlueSMiRF v2 with headers and soldered male header pins on the SerLCD, you can place them in a breadboard. A 9V power supply and barrel jack adapter was used to power both boards. The + pin from the adapter was connected to the SerLCD's RAW pin which is regulated down to 3.3V. Of course, the - pin from the adapter was also connected for reference ground.</p> Receiving BlueSMiRF v2Pinout              SparkFun 16x2 SerLCDRGB Backlight (Qwiic) Pinout              Power Supply (5V TO 9V)with Barrel Jack Adapter              TXO RX VCC + RAW +, Center Positive Pin GND GND -, Sleeve <p>If you have not already, make sure to upload the Arduino example code from the basic serial UART example. For your convenience, the code shown below was pulled from the OpenLCD's Serial Examples folder. Select the board (in this case, the Tools &gt; Board &gt; Arduino AVR Boards (arduino) &gt; Arduino Uno) and COM port that the board enumerated to. Then hit the upload button.</p> <pre><code>/*\n OpenLCD is an LCD with serial/I2C/SPI interfaces.\n By: Nathan Seidle\n SparkFun Electronics\n Date: April 19th, 2015\n License: This code is public domain but you buy me a beer if you use this and we meet someday (Beerware license).\n\n This example shows how to display a counter on the display over serial. We use software serial because if \n OpenLCD is attached to an Arduino's hardware serial port during bootloading  it can cause problems for both devices.\n\n To get this code to work, attached an OpenLCD to an Arduino Uno using the following pins:\n RX (OpenLCD) to Pin 7 (Arduino)\n VIN to 5V\n GND to GND\n\n*/\n\n#include &lt;SoftwareSerial.h&gt;\n\nSoftwareSerial OpenLCD(6, 7); //RX, TX\n\nbyte counter = 0;\n\nvoid setup()\n{\n  Serial.begin(9600); //Start serial communication at 9600 for debug statements\n  Serial.println(\"OpenLCD Example Code\");\n\n  OpenLCD.begin(9600); //Start communication with OpenLCD\n}\n\nvoid loop()\n{\n  //Send the clear command to the display - this returns the cursor to the beginning of the display\n  OpenLCD.write('|'); //Setting character\n  OpenLCD.write('-'); //Clear display\n\n  OpenLCD.print(\"Hello World!    Counter: \"); //For 16x2 LCD\n  //OpenLCD.print(\"Hello World!        Counter: \"); //For 20x4 LCD\n  OpenLCD.print(counter++);\n\n  delay(250); //Hang out for a bit\n}\n</code></pre> <p>With both boards powered, follow the steps to pair and connect the two BlueSMiRFs together. If all is well, you should see the RedBoard Plus transmitting the same message to the SerLCD. Instead of a wired connection, a pair of BlueSMiRF's were used!</p> Wireless Serial LCD with the RedBoard Plus <p>Try adding a Qwiic-enabled device like the Human Presence and Motion Sensor - (STHS34PF80) to the RedBoard Plus and writing code to display a message notifying you when someone has passed by a door. Then place the SerLCD by your desk so that you can monitor the traffic.</p>"},{"location":"single_page/#firmware-update","title":"Firmware Update","text":"<p>From time to time, SparkFun will release new firmware for the BlueSMiRF v2 product line to add and improve functionality.  For most users, firmware can be upgraded over a 2.4GHz WiFi network using the OTA method. Users can also update the firmware manually using a Command Line Interface (CLI)</p>"},{"location":"single_page/#updating-firmware-over-the-air-ota","title":"Updating Firmware Over-The-Air (OTA)","text":"<p>Once the <code>AT-WiFiSSID</code> and <code>AT-WiFiPassword</code> settings have been entered for your local WiFi network, the <code>ATC</code> command can be issued to check for new firmware. If new firmware is available, send the <code>ATU</code> command to begin an update.</p>"},{"location":"single_page/#manually-updating-firmware-over-serial","title":"Manually Updating Firmware Over Serial","text":"<p>Because it's much easier to use, we recommend the OTA firmware update process. If that fails for some reason, the following CLI method can be used.</p>"},{"location":"single_page/#entering-bootloader-mode","title":"Entering Bootloader Mode","text":"<p>Hold the PAIR button while powering the BlueSMiRF v2. This will cause the ESP32 to enter bootloader mode. Once the BlueSMiRF v2 is in bootloader mode, the STATUS LED will be dimly lit and the CONNECT LED will be off.</p> <p>We recommend using a breadboard or jumper wires to connect the BlueSMiRF to a USB-to-Serial connection. At a minimum, you will need to connect the UART pins, power, and ground as stated in the hardware hookup. Remember, the TX and RX connections must be crossed over.</p> USB-to-Serial ConverterPinout              Intermediate Wire Connection BlueSMiRF v2Pinout              DTR RTS RXI RXI TXO TXO 3V3 VCC CTS CTS GND GND <p>Note</p> <p>The connection also includes two additional connections for flow control: RTS and CTS. These two connections are not needed for a basic serial UART connection. However, using all six wires can help make a tighter connection on the 1x6 header. The wire colors also connect TXO-to-RXI and RXI-to-RXO to indicate that it is not a direct connection between the two boards and the 1x6 header.</p> USB-to-Serial Converter (CH340) to BlueSMiRF v2 Header with an Additional Stackable Header"},{"location":"single_page/#windows","title":"Windows","text":"<p>Identify the COM port the USB-to-Serial device enumerated at. The easiest way to do this is to open the Device Manager under the Ports (COM &amp; LPT) tree:</p> CH340 is on COM10 as shown in Device Manager <p>If the COM port is not showing, be sure the unit is turned On. If an unknown device is appearing, you\u2019ll need to install drivers for your USB-to-serial device (we'll assume that you are using the CH340).</p> <p>Once the correct COM port is identified, head to the GitHub repo for the BlueSMiRF v2 binaries and download all the contents. Unzip the contents in a known directory and copy the path.</p> Download BlueSMiRF v2 Binaries GitHub Repo (ZIP) <p>Open a command prompt (Windows button + r then type \u2018 cmd \u2019). Head to the directory where you unzipped the folder. You'll need to use the <code>cd</code> commmand, paste the path where you unzipped the folder, and hit the enter key.</p> Change Path to BlueSmiRF Binaries Folder <p>You'll then need to run the 'batch_program.bat' along with the binary file name and COM port. Enter the following command below, where COM4 should be replaced by the COM port you identified earlier and BlueSMiRF_Firmware_v1_0.bin is the firmware that you are updating to. Make sure to send an additional key to run the batch file.</p> <pre><code>batch_program.bat BlueSMiRF_Firmware_v1_0.bin COM4\n</code></pre> batch_program.bat running esptool <p>After about 20 seconds, you should see the following message: <code>Done programming! Ready for next board.</code></p> Successfully Programmed BlueSMiRF v2 - ESP32 <p>The batch file runs the following commands, where COM4 is replaced with the COM port that the BlueSMiRF product enumerated at and BlueSMiRF_Firmware_vx_x.bin is the firmware you would like to load.</p> <pre><code>esptool.exe --chip esp32 --port COM4 --baud 921600 --before default_reset --after hard_reset write_flash -z --flash_mode dio --flash_freq 80m --flash_size 8MB 0x1000 bins/bootloader.bin 0x8000 bins/partitions.bin 0xe000 bins/boot_app0.bin 0x10000 BlueSMiRF_Firmware_v1_0.bin\n</code></pre> <p>Note</p> <p>Some users have reported the <code>921600</code> baud rate does not work. Decrease this to <code>115200</code> as needed.</p> <p>Tip</p> <p>Finished programming the ESP32? Type CTRL + C , Y , and ENTER to exit the batch file. You can also close the window.</p> <p>Upon completion, the BlueSMiRF v2 must be power cycled to exit bootloader mode. Once power cycled, the BlueSMiRF will start running the new firmware.</p> <p>Note</p> <p>We recommend disconnecting the USB cable from the USB-to-Serial Converter or your computer's COM port.</p>"},{"location":"single_page/#macos-linux","title":"macOS / Linux","text":"<p>Get esptool.py. Connect a USB A to C cable from your computer to the USB-to-Serial. Now identify the COM port the USB-to-serial device enumerated at.</p> <p>If the COM port is not showing, be sure the unit is turned On. If an unknown device is appearing, you\u2019ll need to install drivers for your USB-to-serial device (we'll assume that you are using the CH340).</p> <p>Once the correct COM port is identified, head to the GitHub repo for the BlueSMiRF v2 binaries and download all the contents. Unzip the contents in a known directory and copy the path.</p> Download BlueSMiRF v2 Binaries GitHub Repo (ZIP) <p>Open a Terminal window and run the following command, where /dev/ttyUSB0 is replaced with the port that the USB-to-Serial board enumerated at and BlueSMiRF_Firmware_vx_x.bin is the firmware you would like to load.</p> <pre><code>py esptool.py --chip esp32 --port /dev/ttyUSB0 --baud 921600 --before default_reset --after hard_reset write_flash  -z --flash_mode dio --flash_freq 80m --flash_size 8MB 0x1000 bins/bootloader.bin 0x8000 bins/partitions.bin 0xe000 bins/boot_app0.bin 0x10000 BlueSMiRF_Firmware_vx_x.bin\n</code></pre> <p>Note</p> <p>Some users have reported the <code>921600</code> baud rate does not work. Decrease this to <code>115200</code> as needed.</p> <p>Tip</p> <p>Finished programming the ESP32? Type CTRL + C , Y , and ENTER to exit the batch file. You can also close the window.</p> <p>Upon completion, the BlueSMiRF must be power cycled to exit bootloader mode. Once power cycled, the BlueSMiRF will start running the new firmware.</p> <p>Note</p> <p>We recommend disconnecting the USB cable from the USB-to-Serial Converter or your computer's COM port.</p>"},{"location":"single_page/#troubleshooting","title":"Troubleshooting","text":""},{"location":"single_page/#general-troubleshooting-help","title":"General Troubleshooting Help","text":"<p>Note</p> <p>  Not working as expected and need help?  </p> <p>If you need technical assistance and more information on a product that is not working as you expected, we recommend heading on over to the SparkFun Technical Assistance page for some initial troubleshooting. </p> <p>SparkFun Technical Assistance Page</p> <p>If you don't find what you need there, the SparkFun Forums are a great place to find and ask for help. If this is your first visit, you'll need to create a Forum Account to search product forums and post questions.</p> <p>Create New Forum Account Log Into SparkFun Forums</p>"},{"location":"single_page/#issues-uploading-code-manually-via-cli","title":"Issues Uploading Code Manually via CLI","text":"<p>If you are seeing the following error when attempting to flash the binaries:</p> <pre>\n    <code>A fatal error occurred: Failed to connect to ESP32: No serial data received. For troubleshooting steps visit: https://docs.espressif.com/projects/esptool/en/latest/troubleshooting.md_in_html\nDone programming! Ready for next board.\nPress any key to continue . . .\n    </code>\n</pre> Error Programming BlueSMiRF v2 - ESP32 <p>Make sure to:</p> <ul> <li>ensure that the wires are making connection and not loose</li> <li>wired correctly between the USB-to-Serial Converter and your BlueSMiRF v2</li> <li>COM Port is the same one that the USB-to-Serial converter enumerated to on your computer</li> <li>install the appropriate drivers</li> <li>in Bootloader Mode</li> </ul> <p>Still having issues? Try a power cycle by following the steps below:</p> <ul> <li>disconnecting the USB-to-serial converter from your computer</li> <li>pushing down on the pair button for bootloader mode</li> <li>connecting the USB-to-serial converter back to your computer</li> </ul>"},{"location":"single_page/#can-the-bluesmirf-v2-be-used-for-wireless-serial-upload-with-an-arduino","title":"Can the BlueSMiRF v2 be used for wireless serial upload with an Arduino?","text":"<p>Currently, there is not support for wireless serial upload with an Arduino. We recommend removing the BlueSMiRF v2 and using a USB-to-serial converter to upload code to an Arduino.</p>"},{"location":"single_page/#resources","title":"Resources","text":"<p>Now that you've successfully got your SparkFun BlueSMiRF v2 up and running, it's time to incorporate it into your own project! For more information, check out the resources below:</p> <ul> <li>PTH<ul> <li>Schematic (PDF)</li> <li>KiCad Files (ZIP)</li> <li>3D Model (STEP)</li> <li>Board Dimensions (PNG)</li> </ul> </li> <li>SMD, with headers<ul> <li>Schematic (PDF)</li> <li>KiCad Files (ZIP)</li> <li>3D Model (STEP)</li> <li>Board Dimensions (PNG)</li> </ul> </li> <li>Datasheet (PDF) (ESP32-PICO-MINI-02)</li> <li>Firmware</li> <li>GitHub Hardware Repo</li> <li>SFE Product Showcase</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#general-troubleshooting-help","title":"General Troubleshooting Help","text":"<p>Note</p> <p>  Not working as expected and need help?  </p> <p>If you need technical assistance and more information on a product that is not working as you expected, we recommend heading on over to the SparkFun Technical Assistance page for some initial troubleshooting. </p> <p>SparkFun Technical Assistance Page</p> <p>If you don't find what you need there, the SparkFun Forums are a great place to find and ask for help. If this is your first visit, you'll need to create a Forum Account to search product forums and post questions.</p> <p>Create New Forum Account Log Into SparkFun Forums</p>"},{"location":"troubleshooting/#issues-uploading-code-manually-via-cli","title":"Issues Uploading Code Manually via CLI","text":"<p>If you are seeing the following error when attempting to flash the binaries:</p> <pre>\n    <code>A fatal error occurred: Failed to connect to ESP32: No serial data received. For troubleshooting steps visit: https://docs.espressif.com/projects/esptool/en/latest/troubleshooting.md_in_html\nDone programming! Ready for next board.\nPress any key to continue . . .\n    </code>\n</pre> Error Programming BlueSMiRF v2 - ESP32 <p>Make sure to:</p> <ul> <li>ensure that the wires are making connection and not loose</li> <li>wired correctly between the USB-to-Serial Converter and your BlueSMiRF v2</li> <li>COM Port is the same one that the USB-to-Serial converter enumerated to on your computer</li> <li>install the appropriate drivers</li> <li>in Bootloader Mode</li> </ul> <p>Still having issues? Try a power cycle by following the steps below:</p> <ul> <li>disconnecting the USB-to-serial converter from your computer</li> <li>pushing down on the pair button for bootloader mode</li> <li>connecting the USB-to-serial converter back to your computer</li> </ul>"},{"location":"troubleshooting/#can-the-bluesmirf-v2-be-used-for-wireless-serial-upload-with-an-arduino","title":"Can the BlueSMiRF v2 be used for wireless serial upload with an Arduino?","text":"<p>Currently, there is not support for wireless serial upload with an Arduino. We recommend removing the BlueSMiRF v2 and using a USB-to-serial converter to upload code to an Arduino.</p>"},{"location":"github/contribute/","title":"Contribute: Help Fix our Mistake!","text":"<p>Spot something wrong? Feel free to contribute our open-source design and documentation. </p>"},{"location":"github/contribute/#improve-our-documentation","title":"Improve our Documentation","text":"<p>All of this documentation can be modified by you! Please help us make it better.</p> <ul> <li>These pages are contained in the <code>docs</code> folder of the SparkFun BlueSMiRF v2 repository.</li> </ul>"},{"location":"github/contribute/#submit-a-correction","title":"Submit a Correction","text":"<ol> <li>Fork this repo</li> <li>Add your corrections or improvements to the markdown file</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the documentation specialist will automatically be notified.</li> <li>We will review your suggested improvements to make sure they are correct and fit within our documentation standards.</li> </ul> </li> </ol>"},{"location":"github/contribute/#improve-our-hardware-design","title":"Improve our Hardware Design","text":"<p>All of our designs are open-source! Please help us make it better.</p> <ul> <li>Our board design files are contained in the <code>Hardware</code> folder of the SparkFun BlueSMiRF v2 repository.</li> </ul>"},{"location":"github/contribute/#submit-a-design-improvement","title":"Submit a Design Improvement","text":"<ol> <li>Fork this repo</li> <li>Add your design improvements</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the engineer in charge of the original design will automatically be notified.</li> <li>We will review your suggested improvements, if they are within our board design standards and meet our product design requirements, we will flag these changes for our next board revision. (Please note, that even if your suggestion is accepted, these changes may not be immediate. We may have to cycle through our current product inventory first.)</li> </ul> </li> </ol>"},{"location":"github/contribute/#contributors","title":"Contributors","text":"<p>Let's provided some recognition to the contributors for this project!</p> <p> </p>"},{"location":"github/file_issue/","title":"Did we make a mistake?","text":"<p>Spot something wrong? Please let us know. </p> <p>Attention</p> <p>This is not where customers should seek assistance on a product. If you require technical assistance or have questions about a product that is not working as expected, please head over to the SparkFun Technical Assistance page for some initial troubleshooting.  SparkFun Technical Assistance Page </p> <p>If you can't find what you need there, you'll need a Forum Account to search product forums and post questions.</p>"},{"location":"github/file_issue/#discrepancies-in-the-documentation","title":"Discrepancies in the Documentation","text":"<p>All of this documentation can be modified by you! Please help us make it better.</p> <ul> <li>The documentation files for these pages are contained in the <code>docs</code> folder of the SparkFun BlueSMiRF v2 repository.</li> </ul>"},{"location":"github/file_issue/#spot-something-wrong","title":"Spot something wrong?","text":"<p>If a section of the documentation is incorrect, please open an issue and let us know.</p>"},{"location":"github/file_issue/#do-you-have-a-suggested-correction","title":"Do you have a suggested correction?","text":"<ol> <li>With a GitHub account, fork this repo</li> <li>Add your correction(s) or improvement(s) to the markdown file(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the documentation specialist will automatically be notified.</li> <li>We will review your suggested improvement(s) to make sure they are correct and fit within our documentation standards.</li> </ul> </li> </ol>"},{"location":"github/file_issue/#problems-in-the-hardware-design","title":"Problems in the Hardware Design","text":"<p>All of our designs are open-source! Please help us make it better.</p> <ul> <li>Our board design files are contained in the <code>Hardware</code> folder of the SparkFun BlueSMiRF v2 repository.</li> </ul>"},{"location":"github/file_issue/#does-something-not-make-sense","title":"Does something not make sense?","text":"<p>If part of the design is confusing, please open an issue and let us know.</p>"},{"location":"github/file_issue/#did-we-forget-to-include-an-important-function-of-the-board","title":"Did we forget to include an important function of the board?","text":"<ul> <li>Please keep in mind that we may intentionally exclude certain functions of the board to meet our product design requirements. (For example, our Qwiic Micro boards are intended to fit on a small board layout and only use I<sup>2</sup>C communication; therefore, we may not have the SPI and interrupt pins available for users.)</li> <li>If part of the board's functionality is missing, please open an issue and file a feature request.</li> </ul>"},{"location":"github/file_issue/#do-you-wish-to-contribute-directly-to-improving-the-board-design","title":"Do you wish to contribute directly to improving the board design?","text":"<ol> <li>With a GitHub account, Fork this repo</li> <li>Add your design improvement(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the engineer in charge of the original design will automatically be notified.</li> <li>We will review your suggested improvement(s), if they are within our board design standards and meet our product design requirements, we will flag these changes for our next board revision. (Please note, that even if your suggestion is accepted, these changes may not be immediate. We may have to cycle through our current product inventory first.)</li> </ul> </li> </ol>"},{"location":"javascript/","title":"javascript directory","text":"<p>This folder should contain the files for the custom javascript that is enabled in the product documentation</p>"}]}